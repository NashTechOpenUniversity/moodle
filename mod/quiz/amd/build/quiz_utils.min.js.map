{"version":3,"file":"quiz_utils.min.js","sources":["../src/quiz_utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Render the question slot template for each question in the quiz edit view.\n *\n * @module     mod_quiz/quiz_utils\n * @copyright  2024 The Open University.\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {config} from 'mod_quiz/quiz_toolboxes';\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport {getString, getStrings} from 'core/str';\nimport Prefetch from 'core/prefetch';\nimport dropZoneElement from 'mod_quiz/dragdrop/dropzone';\n\nPrefetch.prefetchStrings('moodle', ['question', 'page']);\nPrefetch.prefetchStrings('quiz', ['removepagebreak', 'addpagebreak', 'questiondependencyremove',\n    'questiondependsonprevious', 'questiondependencyadd', 'questiondependencyfree']);\n\nconst slot = {\n    CSS: {\n        SLOT: 'slot',\n        QUESTIONTYPEDESCRIPTION: 'qtype_description',\n        CANNOT_DEPEND: 'question_dependency_cannot_depend'\n    },\n    CONSTANTS: {\n        SLOTIDPREFIX: 'slot-',\n        QUESTION: JSON.parse(document.querySelector('.config-toolbox').dataset.lang).question,\n    },\n    SELECTORS: {\n        SLOT: 'li.slot',\n        INSTANCENAME: '.instancename',\n        NUMBER: 'span.slotnumber',\n        PAGECONTENT: 'div#page-content',\n        PAGEBREAK: 'span.page_split_join_wrapper',\n        ICON: '.icon',\n        QUESTIONTYPEDESCRIPTION: '.qtype_description',\n        SECTIONUL: 'ul.section',\n        DEPENDENCY_WRAPPER: '.question_dependency_wrapper',\n        DEPENDENCY_LINK: '.question_dependency_wrapper .cm-edit-action',\n        DEPENDENCY_ICON: '.question_dependency_wrapper .icon'\n    },\n\n    /**\n     * Retrieve the slot item from one of its child Nodes.\n     *\n     * @param {HTMLElement} slotComponent The component Node.\n     * @return {Element|null} The Slot Node.\n     */\n    getSlotFromComponent: function(slotComponent) {\n        return slotComponent.closest(this.SELECTORS.SLOT);\n    },\n\n    /**\n     * Determines the slot ID for the provided slot.\n     *\n     * @method getId\n     * @param {HTMLElement} slot The slot to find an ID for.\n     * @return {Number|false} The ID of the slot in question or false if no ID was found.\n     */\n    getId: function(slot) {\n        // We perform a simple substitution operation to get the ID.\n        let id = slot.id.replace(\n            this.CONSTANTS.SLOTIDPREFIX, '');\n\n        // Attempt to validate the ID.\n        id = parseInt(id, 10);\n        if (typeof id === 'number' && isFinite(id)) {\n            return id;\n        }\n        return false;\n    },\n\n    /**\n     * Determines the slot name for the provided slot.\n     *\n     * @method getName\n     * @param {HTMLElement} slot The slot to find a name for.\n     * @return {string|null} The name of the slot in question or null if no name was found.\n     */\n    getName: function(slot) {\n        const instance = slot.querySelector(this.SELECTORS.INSTANCENAME);\n        if (instance) {\n            // ??\n            return instance.firstChild.data;\n        }\n        return null;\n    },\n\n    /**\n     * Determines the slot number for the provided slot.\n     *\n     * @method getNumber\n     * @param {HTMLElement} slot The slot to find the number for.\n     * @return {Number|false} The number of the slot in question or false if no number was found.\n     */\n    getNumber(slot) {\n        if (!slot) {\n            return false;\n        }\n        // We perform a simple substitution operation to get the number.\n        let number = slot.querySelector(this.SELECTORS.NUMBER).textContent.replace(\n            this.CONSTANTS.QUESTION, '');\n        // Attempt to validate the ID.\n        number = parseInt(number, 10);\n        if (!isNaN(number)) {\n            return number;\n        }\n        return false;\n    },\n\n    /**\n     * Updates the slot number for the provided slot.\n     *\n     * @method setNumber\n     * @param {HTMLElement} slot The slot to update the number for.\n     * @param {Number} number The slot number.\n     * @return void\n     */\n    setNumber(slot, number) {\n        let numberNode = slot.querySelector(this.SELECTORS.NUMBER);\n        numberNode.innerHTML = '<span class=\"accesshide\">' + this.CONSTANTS.QUESTION + '</span> ' + number;\n    },\n\n    /**\n     * Returns a list of all slot elements on the page.\n     *\n     * @method getSlots\n     * @return {Element[]} An array containing slot nodes.\n     */\n    getSlots() {\n        return document.querySelectorAll(this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL + ' ' + this.SELECTORS.SLOT);\n    },\n\n    /**\n     * Returns a list of all slot elements on the page that have numbers. Excudes description questions.\n     *\n     * @method getSlots\n     * @return {Element[]} An array containing slot nodes.\n     */\n    getNumberedSlots() {\n        let selector = this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL;\n        selector += ' ' + this.SELECTORS.SLOT + ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')';\n        return document.querySelectorAll(selector);\n    },\n\n    /**\n     * Returns the previous slot to the given slot.\n     *\n     * @param {HTMLElement} node - The node we want to get the previous sibling.\n     * @param {string}  selector the selector we want to match with the sibling.\n     * @return {HTMLElement|false} The previous slot node or false.\n     */\n     getPrevious: function(node, selector) {\n        let previousSlot = node.previousElementSibling;\n        while (previousSlot) {\n            if (previousSlot.matches(selector)) {\n                return previousSlot;\n            }\n            previousSlot = previousSlot.previousElementSibling;\n        }\n        return false;\n    },\n\n\n    /**\n     * Returns the previous numbered slot to the given slot.\n     * Ignores slots containing description question types.\n     *\n     * @param {HTMLElement} slot Slot node\n     * @return {Element|false} The previous slot node or false.\n     */\n    getPreviousNumbered(slot) {\n        let previous = slot.previousElementSibling;\n        while (previous) {\n            if (!previous.matches(this.SELECTORS.SLOT + ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')')) {\n                previous = previous.previousElementSibling;\n            } else {\n                return previous;\n            }\n        }\n\n        let section = slot.closest('li.section').previousElementSibling;\n        while (section) {\n            const questions = section.querySelectorAll(this.SELECTORS.SLOT +\n                ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')');\n            if (questions.length > 0) {\n                return questions[questions.length - 1];\n            }\n            section = section.previousElementSibling;\n        }\n        return false;\n    },\n\n    /**\n     * Reset the order of the numbers given to each slot.\n     *\n     * @method reorderSlots\n     * @return void\n     */\n    reorderSlots() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n\n        // Loop through slots incrementing the number each time.\n        slots.forEach((slot, index) => {\n            if (!page.getPageFromSlot(slot)) {\n                // Move the next page to the front.\n                const nextPage = slot.nextElementSibling;\n                if (nextPage) {\n                    slot.parentNode.insertBefore(nextPage, slot);\n                }\n            }\n\n            if (slot.classList.contains(this.CSS.QUESTIONTYPEDESCRIPTION)) {\n                return;\n            }\n\n            // Set slot number.\n            this.setNumber(slot, index + 1);\n            slot.dataset.slotorder = index + 1;\n            slot.dataset.page = page.getPageFromSlot(slot).id.replace(/^\\D+/g, '');\n        });\n    },\n\n    /**\n     * Add class only-has-one-slot to those sections that need it.\n     *\n     * @method updateOneSlotSections\n     * @return void\n     */\n    updateOneSlotSections() {\n        document.querySelectorAll('.mod-quiz-edit-content ul.slots li.section').forEach(section => {\n            if (section.querySelectorAll(this.SELECTORS.SLOT).length > 1) {\n                section.classList.remove('only-has-one-slot');\n            } else {\n                section.classList.add('only-has-one-slot');\n            }\n        });\n    },\n\n    /**\n     * Remove a slot and related elements from the list of slots.\n     *\n     * @method remove\n     * @param {HTMLElement} slot Slot node.\n     * @return void\n     */\n    remove: function(slot) {\n        const pageElement = page.getPageFromSlot(slot);\n        slot.remove();\n\n        // Is the page empty.\n        if (!page.isEmpty(pageElement)) {\n            return;\n        }\n        // If so remove it. Including add menu and page break.\n        page.remove(pageElement, false);\n    },\n\n    /**\n     * Returns a list of all page break elements on the page.\n     *\n     * @method getPageBreaks\n     * @return {Element[]} An array containing page break nodes.\n     */\n    getPageBreaks() {\n        let selector = this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL;\n        selector += ' ' + this.SELECTORS.SLOT + this.SELECTORS.PAGEBREAK;\n        return document.querySelectorAll(selector);\n    },\n\n    /**\n     * Retrieve the page break element item from the given slot.\n     *\n     * @method getPageBreak\n     * @param {HTMLElement} slot Slot node\n     * @return {Element|null} The Page Break Node.\n     */\n    getPageBreak: function(slot) {\n        return slot.querySelector(this.SELECTORS.PAGEBREAK);\n    },\n\n    /**\n     * Add a page break and related elements to the list of slots.\n     *\n     * @method addPageBreak\n     * @param {HTMLElement} slot Slot node.\n     * @return {HTMLElement} PageBreak node\n     */\n    addPageBreak(slot) {\n        let nodeText = config.addpageiconhtml;\n        nodeText = nodeText.replace('%%SLOT%%', this.getNumber(slot));\n        let pageBreak = document.createElement('div');\n        pageBreak.innerHTML = nodeText;\n        slot.querySelector('div').insertAdjacentElement('afterend', pageBreak);\n        return pageBreak;\n    },\n\n    /**\n     * Remove a pagebreak from the given slot.\n     *\n     * @method removePageBreak\n     * @param {HTMLElement} slot Slot node.\n     * @return boolean\n     */\n    removePageBreak: function(slot) {\n        const pageBreak = this.getPageBreak(slot);\n        if (!pageBreak) {\n            return false;\n        }\n        pageBreak.remove();\n        return true;\n    },\n\n    /**\n     * Reorder each pagebreak by iterating through each related slot.\n     *\n     * @method reorderPageBreaks\n     * @return void\n     */\n    reorderPageBreaks: async function() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n        let slotNumber = 0;\n        const [stringRemovePageBreak, stringAddPageBreak] = await getStrings([\n            {key: 'removepagebreak', component: 'quiz'},\n            {key: 'addpagebreak', component: 'quiz'},\n        ]);\n\n        slots.forEach((slot, key) => {\n            slotNumber++;\n            let pageBreak = this.getPageBreak(slot);\n            const nextItem = slot.nextElementSibling && slot.nextElementSibling.matches('li.activity')\n                ? slot.nextElementSibling : null;\n            if (!nextItem) {\n                // Last slot in a section. Should not have an icon.\n                return;\n            }\n\n            // No pagebreak and not last slot. Add one.\n            if (!pageBreak) {\n                pageBreak = this.addPageBreak(slot);\n            }\n\n            // Remove last page break if there is one.\n            if (pageBreak && key === slots.length - 1) {\n                this.removePageBreak(slot);\n            }\n\n            // Get page break anchor element.\n            const pageBreakLink = pageBreak.firstElementChild;\n\n            // Get the correct title.\n            let action = '';\n            let iconName = '';\n            let stringPagebreak = '';\n            if (page.isPage(nextItem)) {\n                action = 'removepagebreak';\n                iconName = 'e/remove_page_break';\n                stringPagebreak = stringRemovePageBreak;\n            } else {\n                action = 'addpagebreak';\n                iconName = 'e/insert_page_break';\n                stringPagebreak = stringAddPageBreak;\n            }\n\n            // Update the link and image titles\n            pageBreakLink.title = stringPagebreak;\n            pageBreakLink.dataset.action = action;\n\n            // Update the image title.\n            const icon = pageBreakLink.querySelector(this.SELECTORS.ICON);\n            icon.title = stringPagebreak;\n            icon.alt = stringPagebreak;\n\n            // Update the image src.\n            icon.src = M.util.image_url(iconName);\n\n            // Get anchor url parameters as an associative array.\n            const params = new URLSearchParams(pageBreakLink.href);\n            // Update slot number.\n            params.set('slot', slotNumber + '');\n            // Update the anchor.\n            if (pageBreakLink.href) {\n                pageBreakLink.href = `${pageBreakLink.href.split('?')[0]}?${params.toString()}`;\n            }\n        });\n    },\n\n    /**\n     * Update the dependency icons.\n     *\n     * @method updateAllDependencyIcons\n     * @return void\n     */\n     updateAllDependencyIcons: function() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n        let slotNumber = 0;\n        let previousSlot = null;\n\n        // Loop through slots incrementing the number each time.\n        slots.forEach(slot => {\n            slotNumber++;\n\n            const dependencyWrapper = slot.querySelector(this.SELECTORS.DEPENDENCY_WRAPPER);\n            if (slotNumber === 1 || previousSlot?.dataset.canfinish === '0') {\n                dependencyWrapper.classList.add(this.CSS.CANNOT_DEPEND);\n            } else {\n                dependencyWrapper.classList.remove(this.CSS.CANNOT_DEPEND);\n            }\n            this.updateDependencyIcon(slot, null);\n\n            previousSlot = slot;\n        });\n    },\n\n    /**\n     * Update the slot icon to indicate the new requiresPrevious state.\n     *\n     * @param {HTMLElement} slot - Slot node\n     * @param {boolean|null} requiresPrevious - Whether this node now requires the previous one.\n     * @return void\n     */\n    updateDependencyIcon: async function(slot, requiresPrevious) {\n        const link = slot.querySelector(this.SELECTORS.DEPENDENCY_LINK);\n        const icon = slot.querySelector(this.SELECTORS.DEPENDENCY_ICON);\n        const previousSlot = this.getPrevious(slot, this.SELECTORS.SLOT);\n        const a = {thisq: this.getNumber(slot)};\n\n        if (previousSlot) {\n            a.previousq = this.getNumber(previousSlot);\n        }\n\n        if (requiresPrevious === null) {\n            requiresPrevious = link.dataset.action === 'removedependency';\n        }\n\n        if (requiresPrevious) {\n            const [removeDependencyString, dependPreviousString] = await getStrings([\n                {key: 'questiondependencyremove', component: 'quiz', a},\n                {key: 'questiondependsonprevious', component: 'quiz'}\n            ]);\n            link.title = removeDependencyString;\n            link.dataset.action = 'removedependency';\n            Templates.renderPix('t/locked', 'core', dependPreviousString)\n                .then((html) => {\n                    icon.parentNode.innerHTML = html;\n                    return true;\n                }).catch(Notification.exception);\n        } else {\n            const [addDependencyString, dependFreeString] = await getStrings([\n                {key: 'questiondependencyadd', component: 'quiz', a},\n                {key: 'questiondependencyfree', component: 'quiz'}\n            ]);\n            link.title = addDependencyString;\n            link.dataset.action = 'adddependency';\n            Templates.renderPix('t/unlocked', 'core', dependFreeString)\n                .then((html) => {\n                    icon.parentNode.innerHTML = html;\n                    return true;\n                }).catch(Notification.exception);\n        }\n    },\n};\n\nconst page = {\n    CSS: {\n        PAGE: 'page'\n    },\n    CONSTANTS: {\n        ACTIONMENUIDPREFIX: 'action-menu-',\n        ACTIONMENUBARIDSUFFIX: '-menubar',\n        ACTIONMENUMENUIDSUFFIX: '-menu',\n        PAGEIDPREFIX: 'page-',\n        PAGENUMBERPREFIX: getString('page', 'moodle') + ' '\n    },\n    SELECTORS: {\n        ACTIONMENU: 'div.moodle-actionmenu',\n        ACTIONMENUBAR: '.menubar',\n        ACTIONMENUMENU: '.menu',\n        ADDASECTION: '[data-action=\"addasection\"]',\n        PAGE: 'li.page',\n        INSTANCENAME: '.instancename',\n        NUMBER: 'h4'\n    },\n\n    /**\n     * Retrieve the page item from one of its child Nodes.\n     *\n     * @param {HTMLElement} pageComponent - The component Node.\n     * @return {HTMLElement|null} The Page Node.\n     */\n    getPageFromComponent: function(pageComponent) {\n        return pageComponent.closest(this.SELECTORS.PAGE);\n    },\n\n    /**\n     * Retrieve the page item from one of its previous siblings.\n     *\n     * @method getPageFromSlot\n     * @param {HTMLElement} slot The component Node.\n     * @return {Element|null} The Page Node.\n     */\n    getPageFromSlot: function(slot) {\n        let previousElement = slot.previousElementSibling;\n        while (previousElement) {\n            if (previousElement.matches(this.SELECTORS.PAGE)) {\n                return previousElement;\n            }\n            previousElement = previousElement.previousElementSibling;\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns the page ID for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find an ID for.\n     * @return {Number|false} The ID of the page in question or false if no ID was found.\n     */\n    getId: function(page) {\n        // We perform a simple substitution operation to get the ID.\n        let id = page.id.replace(this.CONSTANTS.PAGEIDPREFIX, '');\n\n        // Attempt to validate the ID.\n        id = parseInt(id, 10);\n        if (!isNaN(id) && isFinite(id)) {\n            return id;\n        }\n\n        return false;\n    },\n\n    /**\n     * Updates the page id for the provided page.\n     *\n     * @param {HTMLElement} page - The page to update the number for.\n     * @param {number} id - The id value.\n     * @return void\n     */\n    setId: function(page, id) {\n        page.id = `${this.CONSTANTS.PAGEIDPREFIX}${id}`;\n    },\n\n    /**\n     * Determines the page name for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find a name for.\n     * @return {string|null} The name of the page in question or null if no name was found.\n     */\n    getName: function(page) {\n        const instance = page.querySelector(this.SELECTORS.INSTANCENAME);\n        if (instance && instance.firstChild) {\n            return instance.firstChild.data ?? instance.firstChild;\n        }\n\n        return null;\n    },\n\n    /**\n     * Determines the page number for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find a number for.\n     * @return {number|false} The number of the page in question or false if no number was found.\n     */\n     getNumber: function(page) {\n        // We perform a simple substitution operation to get the number.\n        const numberElement = page.querySelector(this.SELECTORS.NUMBER);\n        if (!numberElement) {\n            return false;\n        }\n\n        let number = numberElement.textContent.replace(this.CONSTANTS.PAGENUMBERPREFIX, '');\n\n        // Attempt to validate the number.\n        number = parseInt(number, 10);\n        if (!isNaN(number) && isFinite(number)) {\n            return number;\n        }\n\n        return false;\n    },\n\n    /**\n     * Updates the page number for the provided page.\n     *\n     * @param {HTMLElement} page - The page to update the number for.\n     * @param {number} number - The number to set for the page.\n     * @return void\n     */\n    setNumber: function(page, number) {\n    const numberElement = page.querySelector(this.SELECTORS.NUMBER);\n        if (numberElement) {\n            getString('page', 'moodle').then(string => {\n                numberElement.textContent = string + ' ' + number;\n            });\n        }\n    },\n\n    /**\n     * Returns a list of all page elements.\n     *\n     * @return {HTMLElement[]} An array containing page nodes.\n     */\n    getPages: function() {\n        return [...document.querySelectorAll(`${slot.SELECTORS.PAGECONTENT} ${slot.SELECTORS.SECTIONUL} ${this.SELECTORS.PAGE}`)];\n    },\n\n    /**\n     * Is the given element a page element?\n     *\n     * @param {HTMLElement} page - Page node\n     * @return {boolean}\n     */\n    isPage: function(page) {\n        return page && page.classList.contains(this.CSS.PAGE);\n    },\n\n    /**\n     * Add a page and related elements to the list of slots.\n     *\n     * @param {HTMLElement|String} beforeNode - Element to add before.\n     * @return {HTMLElement} - Page node\n     */\n    add: function(beforeNode) {\n        const pageFromSlot = this.getPageFromSlot(beforeNode);\n        const pageNumber = this.getNumber(pageFromSlot) + 1;\n        const pageHtml = config.pagehtml;\n\n        // Normalize the page number.\n        const pageHtmlWithNumber = pageHtml.replace(/%%PAGENUMBER%%/g, pageNumber);\n\n        // Create the page node.\n        const page = document.createElement('div');\n        page.innerHTML = pageHtmlWithNumber;\n        const pageNode = page.firstElementChild;\n\n        // Insert in the correct place.\n        beforeNode.insertAdjacentElement('afterend', pageNode);\n        // Assign it as a drop target.\n        new dropZoneElement({\n            element: pageNode,\n        });\n        // Enhance the add menu to make if fully visible and clickable.\n        if (typeof M.core.actionmenu !== 'undefined') {\n            M.core.actionmenu.newDOMNode(pageNode);\n        }\n\n        return pageNode;\n    },\n\n    /**\n     * Does the page have at least one slot?\n     *\n     * @method isEmpty\n     * @param {HTMLElement} page Page node\n     * @return boolean\n     */\n    isEmpty: function(page) {\n        let activity = page.nextElementSibling;\n        while (activity && !activity.matches('li.activity')) {\n            activity = activity.nextElementSibling;\n        }\n        if (!activity) {\n            return true;\n        }\n        return !activity.classList.contains('slot');\n    },\n\n    /**\n     * Remove a page and related elements from the list of slots.\n     *\n     * @method remove\n     * @param {HTMLElement} page Page node.\n     * @param  {boolean} keepPageBreak Keep page break flag.\n     * @return void\n     */\n    remove: function(page, keepPageBreak) {\n        // Remove page break from previous slot.\n        let previousSlot = page.previousElementSibling;\n        while (previousSlot && !previousSlot.matches(slot.SELECTORS.SLOT)) {\n            previousSlot = previousSlot.previousElementSibling;\n        }\n        if (!keepPageBreak && previousSlot) {\n            slot.removePageBreak(previousSlot);\n        }\n        page.remove();\n    },\n\n    /**\n     * Reset the order of the numbers given to each page.\n     *\n     * @return void\n     */\n    reorderPages: function() {\n        const pages = this.getPages();\n        let currentPageNumber = 0;\n        pages.forEach((page) => {\n            if (this.isEmpty(page)) {\n                const keepPageBreak = page.nextElementSibling?.classList?.contains('slot') ?? false;\n                this.remove(page, keepPageBreak);\n                return;\n            }\n\n            currentPageNumber++;\n            this.setNumber(page, currentPageNumber);\n            this.setId(page, currentPageNumber);\n        });\n\n        this.reorderActionMenus();\n    },\n    /**\n     * Reset the order of the numbers given to each action menu.\n     *\n     * @return void\n     */\n    reorderActionMenus: function() {\n        const actionMenus = this.getActionMenus();\n        actionMenus.forEach((actionMenu, index) => {\n            const previousActionMenu = actionMenus[index - 1];\n            const previousActionMenuNumber = previousActionMenu ? this.getActionMenuId(previousActionMenu) : 0;\n            const id = previousActionMenuNumber + 1;\n\n            this.setActionMenuId(actionMenu, id);\n\n            const menuBar = actionMenu.querySelector(this.SELECTORS.ACTIONMENUBAR);\n            menuBar.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}${this.CONSTANTS.ACTIONMENUBARIDSUFFIX}`;\n\n            const menuMenu = actionMenu.querySelector(this.SELECTORS.ACTIONMENUMENU);\n            menuMenu.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}${this.CONSTANTS.ACTIONMENUMENUIDSUFFIX}`;\n\n            const addSectionLink = menuMenu.querySelector(this.SELECTORS.ADDASECTION);\n            addSectionLink.href = addSectionLink.href.replace(/\\baddsectionatpage=\\d+\\b/, `addsectionatpage=${id}`);\n        });\n    },\n\n    /**\n     * Returns a list of all action menu elements.\n     *\n     * @return {HTMLElement[]} An array containing action menu nodes.\n     */\n    getActionMenus: function() {\n        return Array.from(\n            document.querySelectorAll(`${slot.SELECTORS.PAGECONTENT} ${slot.SELECTORS.SECTIONUL} ${this.SELECTORS.ACTIONMENU}`)\n        );\n    },\n\n    /**\n     * Returns the ID for the provided action menu.\n     *\n     * @param {HTMLElement} actionMenu - The action menu to find an ID for.\n     * @return {number|false} The ID of the action menu in question or false if no ID was found.\n     */\n    getActionMenuId: function(actionMenu) {\n        const id = actionMenu.id.replace(this.CONSTANTS.ACTIONMENUIDPREFIX, '');\n        const parsedId = parseInt(id, 10);\n        return !isNaN(parsedId) && isFinite(parsedId) ? parsedId : false;\n    },\n\n    /**\n     * Updates the ID for the provided action menu.\n     *\n     * @param {HTMLElement} actionMenu - The action menu to update the ID for.\n     * @param {number} id - The ID value.\n     * @return void\n     */\n    setActionMenuId: function(actionMenu, id) {\n        actionMenu.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}`;\n    },\n};\n\nconst util = {\n    /**\n     * Appends a hidden spinner element to the specified node.\n     *\n     * @param {HTMLElement} node The node the spinner should be added to\n     * @return {HTMLElement} created spinner node\n     */\n    addSpinner: function(node) {\n        const WAITICON = {'pix': \"i/loading_small\", 'component': 'moodle'};\n\n        // Check if spinner is already there\n        const currentSpinner = node.querySelector('.spinner');\n        if (currentSpinner) {\n            return currentSpinner;\n        }\n\n        const spinner = this.createElement('img', {\n            src: M.util.image_url(WAITICON.pix, WAITICON.component),\n            \"class\": 'spinner iconsmall d-none',\n        });\n        node.append(spinner);\n\n        return spinner;\n    },\n\n    createElement: function(tag, attributes) {\n        const element = document.createElement(tag);\n        for (let key in attributes) {\n            element.setAttribute(key, attributes[key]);\n        }\n\n        return element;\n    },\n\n    getNumber: function(content) {\n        return content.replace(/^\\D+/g, '');\n    }\n};\n\nexport {\n    slot,\n    util,\n    page,\n};"],"names":["prefetchStrings","slot","CSS","SLOT","QUESTIONTYPEDESCRIPTION","CANNOT_DEPEND","CONSTANTS","SLOTIDPREFIX","QUESTION","JSON","parse","document","querySelector","dataset","lang","question","SELECTORS","INSTANCENAME","NUMBER","PAGECONTENT","PAGEBREAK","ICON","SECTIONUL","DEPENDENCY_WRAPPER","DEPENDENCY_LINK","DEPENDENCY_ICON","getSlotFromComponent","slotComponent","closest","this","getId","id","replace","parseInt","isFinite","getName","instance","firstChild","data","getNumber","number","textContent","isNaN","setNumber","innerHTML","getSlots","querySelectorAll","getNumberedSlots","selector","getPrevious","node","previousSlot","previousElementSibling","matches","getPreviousNumbered","previous","section","questions","length","reorderSlots","forEach","index","page","getPageFromSlot","nextPage","nextElementSibling","parentNode","insertBefore","classList","contains","slotorder","updateOneSlotSections","remove","add","pageElement","isEmpty","getPageBreaks","getPageBreak","addPageBreak","nodeText","config","addpageiconhtml","pageBreak","createElement","insertAdjacentElement","removePageBreak","reorderPageBreaks","async","slots","slotNumber","stringRemovePageBreak","stringAddPageBreak","key","component","nextItem","pageBreakLink","firstElementChild","action","iconName","stringPagebreak","isPage","title","icon","alt","src","M","util","image_url","params","URLSearchParams","href","set","split","toString","updateAllDependencyIcons","dependencyWrapper","canfinish","updateDependencyIcon","requiresPrevious","link","a","thisq","previousq","removeDependencyString","dependPreviousString","renderPix","then","html","catch","Notification","exception","addDependencyString","dependFreeString","PAGE","ACTIONMENUIDPREFIX","ACTIONMENUBARIDSUFFIX","ACTIONMENUMENUIDSUFFIX","PAGEIDPREFIX","PAGENUMBERPREFIX","ACTIONMENU","ACTIONMENUBAR","ACTIONMENUMENU","ADDASECTION","getPageFromComponent","pageComponent","previousElement","setId","numberElement","string","getPages","beforeNode","pageFromSlot","pageNumber","pageHtmlWithNumber","pagehtml","pageNode","dropZoneElement","element","core","actionmenu","newDOMNode","activity","keepPageBreak","reorderPages","pages","currentPageNumber","_page$nextElementSibl2","_page$nextElementSibl3","reorderActionMenus","actionMenus","getActionMenus","actionMenu","previousActionMenu","getActionMenuId","setActionMenuId","menuMenu","addSectionLink","Array","from","parsedId","addSpinner","WAITICON","currentSpinner","spinner","append","tag","attributes","setAttribute","content"],"mappings":"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"}