{"version":3,"file":"quiz_utils.min.js","sources":["../src/quiz_utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Render the question slot template for each question in the quiz edit view.\n *\n * @module     mod_quiz/quiz_utils\n * @copyright  2024 The Open University.\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {config} from 'mod_quiz/quiz_toolboxes';\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport {getString, getStrings} from 'core/str';\nimport Prefetch from 'core/prefetch';\nimport DropZoneElement from 'mod_quiz/dragdrop/dropzone';\nimport InplaceEditable from 'core/inplace_editable';\n\nPrefetch.prefetchStrings('quiz', ['removepagebreak', 'addpagebreak', 'questiondependencyremove',\n    'questiondependsonprevious', 'questiondependencyadd', 'questiondependencyfree']);\n\nconst slot = {\n    CSS: {\n        SLOT: 'slot',\n        QUESTIONTYPEDESCRIPTION: 'qtype_description',\n        CANNOT_DEPEND: 'question_dependency_cannot_depend'\n    },\n    CONSTANTS: {\n        SLOTIDPREFIX: 'slot-',\n        QUESTION: JSON.parse(document.querySelector('.config-toolbox').dataset.lang).question,\n    },\n    SELECTORS: {\n        SLOT: 'li.slot',\n        INSTANCENAME: '.instancename',\n        NUMBER: 'span.slotnumber',\n        PAGECONTENT: 'div#page-content',\n        PAGEBREAK: 'span.page_split_join_wrapper',\n        ICON: '.icon',\n        QUESTIONTYPEDESCRIPTION: '.qtype_description',\n        SECTIONUL: 'ul.section',\n        DEPENDENCY_WRAPPER: '.question_dependency_wrapper',\n        DEPENDENCY_LINK: '.question_dependency_wrapper .cm-edit-action',\n        DEPENDENCY_ICON: '.question_dependency_wrapper .icon'\n    },\n\n    /**\n     * Retrieve the slot item from one of its child Nodes.\n     *\n     * @param {HTMLElement} slotComponent The component Node.\n     * @return {Element|null} The Slot Node.\n     */\n    getSlotFromComponent: function(slotComponent) {\n        return slotComponent.closest(this.SELECTORS.SLOT);\n    },\n\n    /**\n     * Determines the slot ID for the provided slot.\n     *\n     * @method getId\n     * @param {HTMLElement} slot The slot to find an ID for.\n     * @return {Number|false} The ID of the slot in question or false if no ID was found.\n     */\n    getId: function(slot) {\n        // We perform a simple substitution operation to get the ID.\n        let id = slot.id.replace(\n            this.CONSTANTS.SLOTIDPREFIX, '');\n\n        // Attempt to validate the ID.\n        id = parseInt(id, 10);\n        if (typeof id === 'number' && isFinite(id)) {\n            return id;\n        }\n        return false;\n    },\n\n    /**\n     * Determines the slot name for the provided slot.\n     *\n     * @method getName\n     * @param {HTMLElement} slot The slot to find a name for.\n     * @return {string|null} The name of the slot in question or null if no name was found.\n     */\n    getName: function(slot) {\n        const instance = slot.querySelector(this.SELECTORS.INSTANCENAME);\n        if (instance) {\n            // ??\n            return instance.firstChild.data;\n        }\n        return null;\n    },\n\n    /**\n     * Determines the slot number for the provided slot.\n     *\n     * @method getNumber\n     * @param {HTMLElement} slot The slot to find the number for.\n     * @return {Number|false} The number of the slot in question or false if no number was found.\n     */\n    getNumber(slot) {\n        if (!slot) {\n            return false;\n        }\n        let number;\n        const numberElement = slot.querySelector(this.SELECTORS.NUMBER);\n        // Check if the current slot number is available in the dataset\n        if (numberElement.dataset.currentslotnumber) {\n            number = numberElement.dataset.currentslotnumber;\n        } else {\n            // We perform a simple substitution operation to get the number.\n            number = numberElement.textContent.replace(this.CONSTANTS.QUESTION, '');\n        }\n        // Attempt to validate the ID.\n        number = parseInt(number, 10);\n        if (!isNaN(number)) {\n            return number;\n        }\n        return false;\n    },\n\n    /**\n     * Updates the slot number for the provided slot.\n     * If you want to update the code, you also need to update\n     * make_slot_display_number_in_place_editable in mod/quiz/classes/structure.php\n     *\n     * @method setNumber\n     * @param {HTMLElement} slot The slot to update the number for.\n     * @param {Number} number The slot number.\n     */\n    setNumber(slot, number) {\n        const thisQ = this;\n        let numberNode = slot.querySelector(this.SELECTORS.NUMBER);\n        // We store the number on a data attribute on the containing span, so it is always available,\n        // even when the inplace editable is being re-rendered asynchronously via a promise.\n        numberNode.dataset.currentslotnumber = number;\n        const inplaceElement = InplaceEditable.getInplaceEditable(numberNode);\n            // If slot already have a customised number, then we shouldn't re-render inplace editable element.\n        if (inplaceElement && !numberNode.dataset.customnumber) {\n                // Get the required strings for the template.\n                getStrings([\n                    {key: 'edit_slotdisplaynumber_hint', component: 'mod_quiz'},\n                    {key: 'edit_slotdisplaynumber_label', component: 'mod_quiz', param: number},\n                ]).then(function(strings) {\n                    var context = {\n                        displayvalue: number,\n                        value: number,\n                        itemid: inplaceElement.getItemId(),\n                        component: 'mod_quiz',\n                        itemtype: 'slotdisplaynumber',\n                        edithint: strings[0],\n                        editlabel: strings[1],\n                        editicon: {\n                            'key': 't/editstring',\n                            'component': 'core',\n                            'title': strings[1],\n                        },\n                        linkeverything: true,\n                    };\n                    return Templates.render('core/inplace_editable', context);\n                }).then(function(html, js) {\n                    // Replace the existing node with the new inplace editable element that have a new slot number.\n                    js = typeof js === 'undefined' ? '' : js;\n                    Templates.replaceNodeContents(\n                        numberNode,\n                        '<span class=\"accesshide\">' + thisQ.CONSTANTS.QUESTION + '</span>' + html, js);\n                    return true;\n                }).catch(Notification.exception);\n        }\n    },\n\n    /**\n     * Returns a list of all slot elements on the page.\n     *\n     * @method getSlots\n     * @return {Element[]} An array containing slot nodes.\n     */\n    getSlots() {\n        return document.querySelectorAll(this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL + ' ' + this.SELECTORS.SLOT);\n    },\n\n    /**\n     * Returns a list of all slot elements on the page that have numbers. Excudes description questions.\n     *\n     * @method getSlots\n     * @return {Element[]} An array containing slot nodes.\n     */\n    getNumberedSlots() {\n        let selector = this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL;\n        selector += ' ' + this.SELECTORS.SLOT + ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')';\n        return document.querySelectorAll(selector);\n    },\n\n    /**\n     * Returns the previous slot to the given slot.\n     *\n     * @param {HTMLElement} node - The node we want to get the previous sibling.\n     * @param {string}  selector the selector we want to match with the sibling.\n     * @return {HTMLElement|false} The previous slot node or false.\n     */\n     getPrevious: function(node, selector) {\n        let previousSlot = node.previousElementSibling;\n        while (previousSlot) {\n            if (previousSlot.matches(selector)) {\n                return previousSlot;\n            }\n            previousSlot = previousSlot.previousElementSibling;\n        }\n        return false;\n    },\n\n    /**\n     * Returns the next sibling to the given node that matches a selector.\n     *\n     * @param {HTMLElement} node - The node we want to get the next sibling for.\n     * @param {string} selector - The selector we want to match with the sibling.\n     * @return {HTMLElement|false} The next sibling node that matches the selector, or false.\n     */\n    getNext: function(node, selector) {\n        let nextSlot = node.nextElementSibling;\n        while (nextSlot) {\n            if (nextSlot.matches(selector)) {\n                return nextSlot;\n            }\n            nextSlot = nextSlot.nextElementSibling;\n        }\n        return false;\n    },\n\n    /**\n     * Returns the previous numbered slot to the given slot.\n     * Ignores slots containing description question types.\n     *\n     * @param {HTMLElement} slot Slot node\n     * @return {Element|false} The previous slot node or false.\n     */\n    getPreviousNumbered(slot) {\n        let previous = slot.previousElementSibling;\n        while (previous) {\n            if (!previous.matches(this.SELECTORS.SLOT + ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')')) {\n                previous = previous.previousElementSibling;\n            } else {\n                return previous;\n            }\n        }\n\n        let section = slot.closest('li.section').previousElementSibling;\n        while (section) {\n            const questions = section.querySelectorAll(this.SELECTORS.SLOT +\n                ':not(' + this.SELECTORS.QUESTIONTYPEDESCRIPTION + ')');\n            if (questions.length > 0) {\n                return questions[questions.length - 1];\n            }\n            section = section.previousElementSibling;\n        }\n        return false;\n    },\n\n    /**\n     * Reset the order of the numbers given to each slot.\n     */\n    reorderSlots() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n\n        // Loop through slots incrementing the number each time.\n        slots.forEach((slot, index) => {\n            if (!page.getPageFromSlot(slot)) {\n                // Move the next page to the front.\n                const nextPage = slot.nextElementSibling;\n                if (nextPage) {\n                    slot.parentNode.insertBefore(nextPage, slot);\n                }\n            }\n\n            if (slot.classList.contains(this.CSS.QUESTIONTYPEDESCRIPTION)) {\n                return;\n            }\n\n            // Set slot number.\n            this.setNumber(slot, index + 1);\n            slot.dataset.slotorder = index + 1;\n            slot.dataset.page = page.getPageFromSlot(slot).id.replace(/^\\D+/g, '');\n        });\n    },\n\n    /**\n     * Add class only-has-one-slot to those sections that need it.\n     *\n     * @method updateOneSlotSections\n     */\n    updateOneSlotSections() {\n        document.querySelectorAll('.mod-quiz-edit-content ul.slots li.section').forEach(section => {\n            if (section.querySelectorAll(this.SELECTORS.SLOT).length > 1) {\n                section.classList.remove('only-has-one-slot');\n            } else {\n                section.classList.add('only-has-one-slot');\n            }\n        });\n    },\n\n    /**\n     * Remove a slot and related elements from the list of slots.\n     *\n     * @param {HTMLElement} slot Slot node.\n     */\n    remove: function(slot) {\n        const pageElement = page.getPageFromSlot(slot);\n        slot.remove();\n\n        // Is the page empty.\n        if (!page.isEmpty(pageElement)) {\n            return;\n        }\n        // If so remove it. Including add menu and page break.\n        page.remove(pageElement, false);\n    },\n\n    /**\n     * Returns a list of all page break elements on the page.\n     *\n     * @method getPageBreaks\n     * @return {Element[]} An array containing page break nodes.\n     */\n    getPageBreaks() {\n        let selector = this.SELECTORS.PAGECONTENT + ' ' + this.SELECTORS.SECTIONUL;\n        selector += ' ' + this.SELECTORS.SLOT + this.SELECTORS.PAGEBREAK;\n        return document.querySelectorAll(selector);\n    },\n\n    /**\n     * Retrieve the page break element item from the given slot.\n     *\n     * @method getPageBreak\n     * @param {HTMLElement} slot Slot node\n     * @return {Element|null} The Page Break Node.\n     */\n    getPageBreak: function(slot) {\n        return slot.querySelector(this.SELECTORS.PAGEBREAK);\n    },\n\n    /**\n     * Add a page break and related elements to the list of slots.\n     *\n     * @param {HTMLElement} slot Slot node.\n     * @return {HTMLElement} PageBreak node\n     */\n    addPageBreak(slot) {\n        let nodeText = config.addpageiconhtml;\n        nodeText = nodeText.replace('%%SLOT%%', this.getNumber(slot));\n        let pageBreak = document.createElement('span');\n        pageBreak.innerHTML = nodeText;\n        slot.querySelector('div').insertAdjacentElement('afterend', pageBreak);\n        return pageBreak;\n    },\n\n    /**\n     * Remove a pagebreak from the given slot.\n     *\n     * @param {HTMLElement} slot Slot node.\n     * @return boolean\n     */\n    removePageBreak: function(slot) {\n        const pageBreak = this.getPageBreak(slot);\n        if (!pageBreak) {\n            return false;\n        }\n        pageBreak.remove();\n        return true;\n    },\n\n    /**\n     * Reorder each pagebreak by iterating through each related slot.\n     */\n    reorderPageBreaks: async function() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n        let slotNumber = 0;\n        const [stringRemovePageBreak, stringAddPageBreak] = await getStrings([\n            {key: 'removepagebreak', component: 'quiz'},\n            {key: 'addpagebreak', component: 'quiz'},\n        ]);\n\n        slots.forEach((slot, key) => {\n            slotNumber++;\n            let pageBreak = this.getPageBreak(slot);\n            const nextItem = slot.nextElementSibling && slot.nextElementSibling.matches('li.activity')\n                ? slot.nextElementSibling : null;\n            if (!nextItem) {\n                // Last slot in a section. Should not have an icon.\n                return;\n            }\n\n            // No pagebreak and not last slot. Add one.\n            if (!pageBreak) {\n                pageBreak = this.addPageBreak(slot);\n            }\n\n            // Remove last page break if there is one.\n            if (pageBreak && key === slots.length - 1) {\n                this.removePageBreak(slot);\n            }\n\n            // Get page break anchor element.\n            const pageBreakLink = pageBreak.firstElementChild;\n\n            // Get the correct title.\n            let action = '';\n            let iconName = '';\n            let stringPagebreak = '';\n            if (page.isPage(nextItem)) {\n                action = 'removepagebreak';\n                iconName = 'e/remove_page_break';\n                stringPagebreak = stringRemovePageBreak;\n            } else {\n                action = 'addpagebreak';\n                iconName = 'e/insert_page_break';\n                stringPagebreak = stringAddPageBreak;\n            }\n\n            // Update the link and image titles\n            pageBreakLink.title = stringPagebreak;\n            pageBreakLink.dataset.action = action;\n\n            // Update the image title.\n            const icon = pageBreakLink.querySelector(this.SELECTORS.ICON);\n            icon.title = stringPagebreak;\n            icon.alt = stringPagebreak;\n\n            // Update the image src.\n            icon.src = M.util.image_url(iconName);\n\n            // Get anchor url parameters as an associative array.\n            const params = new URLSearchParams(pageBreakLink.href);\n            // Update slot number.\n            params.set('slot', slotNumber + '');\n            // Update the anchor.\n            if (pageBreakLink.href) {\n                pageBreakLink.href = `${pageBreakLink.href.split('?')[0]}?${params.toString()}`;\n            }\n        });\n    },\n\n    /**\n     * Update the dependency icons.\n     */\n     updateAllDependencyIcons: function() {\n        // Get list of slot nodes.\n        const slots = this.getSlots();\n        let slotNumber = 0;\n        let previousSlot = null;\n\n        // Loop through slots incrementing the number each time.\n        slots.forEach(slot => {\n            slotNumber++;\n\n            const dependencyWrapper = slot.querySelector(this.SELECTORS.DEPENDENCY_WRAPPER);\n            if (slotNumber === 1 || previousSlot?.dataset.canfinish === '0') {\n                dependencyWrapper.classList.add(this.CSS.CANNOT_DEPEND);\n            } else {\n                dependencyWrapper.classList.remove(this.CSS.CANNOT_DEPEND);\n            }\n            this.updateDependencyIcon(slot, null);\n\n            previousSlot = slot;\n        });\n    },\n\n    /**\n     * Update the slot icon to indicate the new requiresPrevious state.\n     *\n     * @param {HTMLElement} slot - Slot node\n     * @param {boolean|null} requiresPrevious - Whether this node now requires the previous one.\n     */\n    updateDependencyIcon: async function(slot, requiresPrevious) {\n        const link = slot.querySelector(this.SELECTORS.DEPENDENCY_LINK);\n        const icon = slot.querySelector(this.SELECTORS.DEPENDENCY_ICON);\n        const previousSlot = this.getPrevious(slot, this.SELECTORS.SLOT);\n        const a = {thisq: this.getNumber(slot)};\n\n        if (previousSlot) {\n            a.previousq = this.getNumber(previousSlot);\n        }\n\n        if (requiresPrevious === null) {\n            requiresPrevious = link.dataset.action === 'removedependency';\n        }\n\n        if (requiresPrevious) {\n            const [removeDependencyString, dependPreviousString] = await getStrings([\n                {key: 'questiondependencyremove', component: 'quiz', a},\n                {key: 'questiondependsonprevious', component: 'quiz'}\n            ]);\n            link.title = removeDependencyString;\n            link.dataset.action = 'removedependency';\n            Templates.renderPix('t/locked', 'core', dependPreviousString)\n                .then((html) => {\n                    icon.parentNode.innerHTML = html;\n                    return true;\n                }).catch(Notification.exception);\n        } else {\n            const [addDependencyString, dependFreeString] = await getStrings([\n                {key: 'questiondependencyadd', component: 'quiz', a},\n                {key: 'questiondependencyfree', component: 'quiz'}\n            ]);\n            link.title = addDependencyString;\n            link.dataset.action = 'adddependency';\n            Templates.renderPix('t/unlocked', 'core', dependFreeString)\n                .then((html) => {\n                    icon.parentNode.innerHTML = html;\n                    return true;\n                }).catch(Notification.exception);\n        }\n    },\n};\n\nconst page = {\n    CSS: {\n        PAGE: 'page'\n    },\n    CONSTANTS: {\n        ACTIONMENUIDPREFIX: 'action-menu-',\n        ACTIONMENUBARIDSUFFIX: '-menubar',\n        ACTIONMENUMENUIDSUFFIX: '-menu',\n        PAGEIDPREFIX: 'page-',\n        PAGENUMBERPREFIX: JSON.parse(document.querySelector('.config-toolbox').dataset.lang).page + ' '\n    },\n    SELECTORS: {\n        ACTIONMENU: 'div.moodle-actionmenu',\n        ACTIONMENUBAR: '.menubar',\n        ACTIONMENUMENU: '.menu',\n        ADDASECTION: '[data-action=\"addasection\"]',\n        PAGE: 'li.page',\n        INSTANCENAME: '.instancename',\n        NUMBER: 'h4'\n    },\n\n    /**\n     * Retrieve the page item from one of its child Nodes.\n     *\n     * @param {HTMLElement} pageComponent - The component Node.\n     * @return {HTMLElement|null} The Page Node.\n     */\n    getPageFromComponent: function(pageComponent) {\n        return pageComponent.closest(this.SELECTORS.PAGE);\n    },\n\n    /**\n     * Retrieve the page item from one of its previous siblings.\n     *\n     * @param {HTMLElement} slot The component Node.\n     * @return {Element|null} The Page Node.\n     */\n    getPageFromSlot: function(slot) {\n        let previousElement = slot.previousElementSibling;\n        while (previousElement) {\n            if (previousElement.matches(this.SELECTORS.PAGE)) {\n                return previousElement;\n            }\n            previousElement = previousElement.previousElementSibling;\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns the page ID for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find an ID for.\n     * @return {Number|false} The ID of the page in question or false if no ID was found.\n     */\n    getId: function(page) {\n        // We perform a simple substitution operation to get the ID.\n        let id = page.id.replace(this.CONSTANTS.PAGEIDPREFIX, '');\n\n        // Attempt to validate the ID.\n        id = parseInt(id, 10);\n        if (!isNaN(id) && isFinite(id)) {\n            return id;\n        }\n\n        return false;\n    },\n\n    /**\n     * Updates the page id for the provided page.\n     *\n     * @param {HTMLElement} page - The page to update the number for.\n     * @param {number} id - The id value.\n     */\n    setId: function(page, id) {\n        page.id = `${this.CONSTANTS.PAGEIDPREFIX}${id}`;\n    },\n\n    /**\n     * Determines the page name for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find a name for.\n     * @return {string|null} The name of the page in question or null if no name was found.\n     */\n    getName: function(page) {\n        const instance = page.querySelector(this.SELECTORS.INSTANCENAME);\n        if (instance && instance.firstChild) {\n            return instance.firstChild.data ?? instance.firstChild;\n        }\n\n        return null;\n    },\n\n    /**\n     * Determines the page number for the provided page.\n     *\n     * @param {HTMLElement} page - The page to find a number for.\n     * @return {number|false} The number of the page in question or false if no number was found.\n     */\n     getNumber: function(page) {\n        // We perform a simple substitution operation to get the number.\n        const numberElement = page.querySelector(this.SELECTORS.NUMBER);\n        if (!numberElement) {\n            return false;\n        }\n\n        let number = numberElement.textContent.replace(this.CONSTANTS.PAGENUMBERPREFIX, '');\n\n        // Attempt to validate the number.\n        number = parseInt(number, 10);\n        if (!isNaN(number) && isFinite(number)) {\n            return number;\n        }\n\n        return false;\n    },\n\n    /**\n     * Updates the page number for the provided page.\n     *\n     * @param {HTMLElement} page - The page to update the number for.\n     * @param {number} number - The number to set for the page.\n     */\n    setNumber: function(page, number) {\n    const numberElement = page.querySelector(this.SELECTORS.NUMBER);\n        if (numberElement) {\n            getString('page', 'moodle').then(string => {\n                numberElement.textContent = string + ' ' + number;\n                return true;\n            }).catch(() => {\n                // Can't get lang string.\n            });\n        }\n    },\n\n    /**\n     * Returns a list of all page elements.\n     *\n     * @return {HTMLElement[]} An array containing page nodes.\n     */\n    getPages: function() {\n        return [...document.querySelectorAll(`${slot.SELECTORS.PAGECONTENT} ${slot.SELECTORS.SECTIONUL} ${this.SELECTORS.PAGE}`)];\n    },\n\n    /**\n     * Is the given element a page element?\n     *\n     * @param {HTMLElement} page - Page node\n     * @return {boolean}\n     */\n    isPage: function(page) {\n        return page && page.classList.contains(this.CSS.PAGE);\n    },\n\n    /**\n     * Add a page and related elements to the list of slots.\n     *\n     * @param {HTMLElement|String} beforeNode - Element to add before.\n     * @return {HTMLElement} - Page node\n     */\n    add: function(beforeNode) {\n        const pageFromSlot = this.getPageFromSlot(beforeNode);\n        const pageNumber = this.getNumber(pageFromSlot) + 1;\n        const pageHtml = config.pagehtml;\n\n        // Normalize the page number.\n        const pageHtmlWithNumber = pageHtml.replace(/%%PAGENUMBER%%/g, pageNumber);\n\n        // Create the page node.\n        const page = document.createElement('div');\n        page.innerHTML = pageHtmlWithNumber;\n        const pageNode = page.firstElementChild;\n\n        // Insert in the correct place.\n        beforeNode.insertAdjacentElement('afterend', pageNode);\n        // Assign it as a drop target.\n        new DropZoneElement({\n            element: pageNode,\n        });\n        // Enhance the add menu to make if fully visible and clickable.\n        if (typeof M.core.actionmenu !== 'undefined') {\n            M.core.actionmenu.newDOMNode(pageNode);\n        }\n\n        return pageNode;\n    },\n\n    /**\n     * Does the page have at least one slot?\n     *\n     * @method isEmpty\n     * @param {HTMLElement} page Page node\n     * @return boolean\n     */\n    isEmpty: function(page) {\n        let activity = page.nextElementSibling;\n        while (activity && !activity.matches('li.activity')) {\n            activity = activity.nextElementSibling;\n        }\n        if (!activity) {\n            return true;\n        }\n        return !activity.classList.contains('slot');\n    },\n\n    /**\n     * Remove a page and related elements from the list of slots.\n     *\n     * @param {HTMLElement} page Page node.\n     * @param  {boolean} keepPageBreak Keep page break flag.\n     */\n    remove: function(page, keepPageBreak) {\n        // Remove page break from previous slot.\n        let previousSlot = page.previousElementSibling;\n        while (previousSlot && !previousSlot.matches(slot.SELECTORS.SLOT)) {\n            previousSlot = previousSlot.previousElementSibling;\n        }\n        if (!keepPageBreak && previousSlot) {\n            slot.removePageBreak(previousSlot);\n        }\n        page.remove();\n    },\n\n    /**\n     * Reset the order of the numbers given to each page.\n     */\n    reorderPages: function() {\n        const pages = this.getPages();\n        let currentPageNumber = 0;\n        pages.forEach((page) => {\n            if (this.isEmpty(page)) {\n                const keepPageBreak = page.nextElementSibling?.classList?.contains('slot') ?? false;\n                this.remove(page, keepPageBreak);\n                return;\n            }\n\n            currentPageNumber++;\n            this.setNumber(page, currentPageNumber);\n            this.setId(page, currentPageNumber);\n        });\n\n        this.reorderActionMenus();\n    },\n\n    /**\n     * Reset the order of the numbers given to each action menu.\n     */\n    reorderActionMenus: function() {\n        const actionMenus = this.getActionMenus();\n        actionMenus.forEach((actionMenu, index) => {\n            const previousActionMenu = actionMenus[index - 1];\n            const previousActionMenuNumber = previousActionMenu ? this.getActionMenuId(previousActionMenu) : 0;\n            const id = previousActionMenuNumber + 1;\n\n            this.setActionMenuId(actionMenu, id);\n\n            const menuBar = actionMenu.querySelector(this.SELECTORS.ACTIONMENUBAR);\n            menuBar.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}${this.CONSTANTS.ACTIONMENUBARIDSUFFIX}`;\n\n            const menuMenu = actionMenu.querySelector(this.SELECTORS.ACTIONMENUMENU);\n            menuMenu.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}${this.CONSTANTS.ACTIONMENUMENUIDSUFFIX}`;\n\n            const addSectionLink = menuMenu.querySelector(this.SELECTORS.ADDASECTION);\n            addSectionLink.href = addSectionLink.href.replace(/\\baddsectionatpage=\\d+\\b/, `addsectionatpage=${id}`);\n        });\n    },\n\n    /**\n     * Returns a list of all action menu elements.\n     *\n     * @return {HTMLElement[]} An array containing action menu nodes.\n     */\n    getActionMenus: function() {\n        return Array.from(\n            document.querySelectorAll(`${slot.SELECTORS.PAGECONTENT} ${slot.SELECTORS.SECTIONUL} ${this.SELECTORS.ACTIONMENU}`)\n        );\n    },\n\n    /**\n     * Returns the ID for the provided action menu.\n     *\n     * @param {HTMLElement} actionMenu - The action menu to find an ID for.\n     * @return {number|false} The ID of the action menu in question or false if no ID was found.\n     */\n    getActionMenuId: function(actionMenu) {\n        const id = actionMenu.id.replace(this.CONSTANTS.ACTIONMENUIDPREFIX, '');\n        const parsedId = parseInt(id, 10);\n        return !isNaN(parsedId) && isFinite(parsedId) ? parsedId : false;\n    },\n\n    /**\n     * Updates the ID for the provided action menu.\n     *\n     * @param {HTMLElement} actionMenu - The action menu to update the ID for.\n     * @param {number} id - The ID value.\n     */\n    setActionMenuId: function(actionMenu, id) {\n        actionMenu.id = `${this.CONSTANTS.ACTIONMENUIDPREFIX}${id}`;\n    },\n};\n\nconst util = {\n    /**\n     * Appends a hidden spinner element to the specified node.\n     *\n     * @param {HTMLElement} node The node the spinner should be added to\n     * @return {HTMLElement} created spinner node\n     */\n    addSpinner: function(node) {\n        const WAITICON = {'pix': \"i/loading_small\", 'component': 'moodle'};\n\n        // Check if spinner is already there\n        const currentSpinner = node.querySelector('.spinner');\n        if (currentSpinner) {\n            return currentSpinner;\n        }\n\n        const spinner = this.createElement('img', {\n            src: M.util.image_url(WAITICON.pix, WAITICON.component),\n            \"class\": 'spinner iconsmall d-none',\n        });\n        node.append(spinner);\n\n        return spinner;\n    },\n\n    /**\n     * Create an element with tag and attributes.\n     *\n     * @param {String} tag\n     * @param {object} attributes\n     * @returns {HTMLElement}\n     */\n    createElement: function(tag, attributes) {\n        const element = document.createElement(tag);\n        for (let key in attributes) {\n            element.setAttribute(key, attributes[key]);\n        }\n\n        return element;\n    },\n\n    /**\n     * Get the number of a string.\n     *\n     * @param {String} content the string contain the number.\n     * @returns {String} the number in a string.\n     */\n    getNumber: function(content) {\n        return content.replace(/^\\D+/g, '');\n    }\n};\n\nexport {\n    slot,\n    util,\n    page,\n};"],"names":["prefetchStrings","slot","CSS","SLOT","QUESTIONTYPEDESCRIPTION","CANNOT_DEPEND","CONSTANTS","SLOTIDPREFIX","QUESTION","JSON","parse","document","querySelector","dataset","lang","question","SELECTORS","INSTANCENAME","NUMBER","PAGECONTENT","PAGEBREAK","ICON","SECTIONUL","DEPENDENCY_WRAPPER","DEPENDENCY_LINK","DEPENDENCY_ICON","getSlotFromComponent","slotComponent","closest","this","getId","id","replace","parseInt","isFinite","getName","instance","firstChild","data","getNumber","number","numberElement","currentslotnumber","textContent","isNaN","setNumber","thisQ","numberNode","inplaceElement","InplaceEditable","getInplaceEditable","customnumber","key","component","param","then","strings","context","displayvalue","value","itemid","getItemId","itemtype","edithint","editlabel","editicon","linkeverything","Templates","render","html","js","replaceNodeContents","catch","Notification","exception","getSlots","querySelectorAll","getNumberedSlots","selector","getPrevious","node","previousSlot","previousElementSibling","matches","getNext","nextSlot","nextElementSibling","getPreviousNumbered","previous","section","questions","length","reorderSlots","forEach","index","page","getPageFromSlot","nextPage","parentNode","insertBefore","classList","contains","slotorder","updateOneSlotSections","remove","add","pageElement","isEmpty","getPageBreaks","getPageBreak","addPageBreak","nodeText","config","addpageiconhtml","pageBreak","createElement","innerHTML","insertAdjacentElement","removePageBreak","reorderPageBreaks","async","slots","slotNumber","stringRemovePageBreak","stringAddPageBreak","nextItem","pageBreakLink","firstElementChild","action","iconName","stringPagebreak","isPage","title","icon","alt","src","M","util","image_url","params","URLSearchParams","href","set","split","toString","updateAllDependencyIcons","dependencyWrapper","canfinish","updateDependencyIcon","requiresPrevious","link","a","thisq","previousq","removeDependencyString","dependPreviousString","renderPix","addDependencyString","dependFreeString","PAGE","ACTIONMENUIDPREFIX","ACTIONMENUBARIDSUFFIX","ACTIONMENUMENUIDSUFFIX","PAGEIDPREFIX","PAGENUMBERPREFIX","ACTIONMENU","ACTIONMENUBAR","ACTIONMENUMENU","ADDASECTION","getPageFromComponent","pageComponent","previousElement","setId","string","getPages","beforeNode","pageFromSlot","pageNumber","pageHtmlWithNumber","pagehtml","pageNode","DropZoneElement","element","core","actionmenu","newDOMNode","activity","keepPageBreak","reorderPages","pages","currentPageNumber","_page$nextElementSibl2","_page$nextElementSibl3","reorderActionMenus","actionMenus","getActionMenus","actionMenu","previousActionMenu","getActionMenuId","setActionMenuId","menuMenu","addSectionLink","Array","from","parsedId","addSpinner","WAITICON","currentSpinner","spinner","append","tag","attributes","setAttribute","content"],"mappings":"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"}