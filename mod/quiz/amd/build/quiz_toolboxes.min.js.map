{"version":3,"file":"quiz_toolboxes.min.js","sources":["../src/quiz_toolboxes.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Manage all toolbox in the quiz question edit page.\n *\n * @module     mod_quiz/quiz_toolboxes\n * @copyright  2024 The Open University.\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {call as fetchMany} from 'core/ajax';\nimport {getString, getStrings} from 'core/str';\nimport Prefetch from 'core/prefetch';\nimport {slot, util, page} from 'mod_quiz/quiz_utils';\nimport Notification from 'core/notification';\nimport {addIconToContainerWithPromise} from 'core/loadingicon';\nimport {eventTypes as inplaceEditableEvents} from 'core/local/inplace_editable/events';\n\n// The CSS classes we use.\nconst CSS = {\n        ACTIVITYINSTANCE: 'activityinstance',\n        AVAILABILITYINFODIV: 'div.availabilityinfo',\n        CONTENTWITHOUTLINK: 'contentwithoutlink',\n        CONDITIONALHIDDEN: 'conditionalhidden',\n        DIMCLASS: 'dimmed',\n        DIMMEDTEXT: 'dimmed_text',\n        EDITINSTRUCTIONS: 'editinstructions',\n        EDITINGMAXMARK: 'editor_displayed',\n        HIDE: 'hide',\n        JOIN: 'page_join',\n        MODINDENTCOUNT: 'mod-indent-',\n        MODINDENTHUGE: 'mod-indent-huge',\n        PAGE: 'page',\n        SECTIONHIDDENCLASS: 'hidden',\n        SECTIONIDPREFIX: 'section-',\n        SELECTMULTIPLE: 'select-multiple',\n        SLOT: 'slot',\n        SHOW: 'editing_show',\n        TITLEEDITOR: 'titleeditor'\n    },\n    // The CSS selectors we use.\n    SELECTOR = {\n        ACTIONAREA: '.actions',\n        ACTIONLINKTEXT: '.actionlinktext',\n        ACTIVITYACTION: 'a.cm-edit-action[data-action], a.editing_maxmark, a.editing_section, input.shuffle_questions',\n        ACTIVITYFORM: 'span.instancemaxmarkcontainer form',\n        ACTIVITYINSTANCE: '.' + CSS.ACTIVITYINSTANCE,\n        SECTIONINSTANCE: '.sectioninstance',\n        ACTIVITYLI: 'li.activity, li.section',\n        ACTIVITYMAXMARK: 'input[name=maxmark]',\n        COMMANDSPAN: '.commands',\n        CONFIGTOOLBOX: '.config-toolbox',\n        CONTENTAFTERLINK: 'div.contentafterlink',\n        CONTENTWITHOUTLINK: 'div.contentwithoutlink',\n        DELETESECTIONICON: 'a.editing_delete .icon',\n        EDITMAXMARK: 'a.editing_maxmark',\n        EDITSECTION: 'a.editing_section',\n        EDITSECTIONICON: 'a.editing_section .icon',\n        EDITSHUFFLEQUESTIONSACTION: 'input.cm-edit-action[data-action]',\n        EDITSHUFFLEAREA: '.instanceshufflequestions .shuffle-progress',\n        HIDE: 'a.editing_hide',\n        HIGHLIGHT: 'a.editing_highlight',\n        INSTANCENAME: 'span.instancename',\n        INSTANCEMAXMARK: 'span.instancemaxmark',\n        INSTANCESECTION: 'span.instancesection',\n        INSTANCESECTIONAREA: 'div.section-heading',\n        MAXMARKCONTAINER: '.instancemaxmarkcontainer',\n        MODINDENTDIV: '.mod-indent',\n        MODINDENTOUTER: '.mod-indent-outer',\n        NUMQUESTIONS: '.numberofquestions',\n        PAGECONTENT: 'div#page-content',\n        PAGELI: 'li.page',\n        SECTIONLI: 'li.section',\n        SECTIONUL: 'ul.section',\n        SECTIONFORM: '.instancesectioncontainer form',\n        SECTIONINPUT: 'input[name=section]',\n        SELECTMULTIPLEBUTTON: '#selectmultiplecommand',\n        SELECTMULTIPLECANCELBUTTON: '#selectmultiplecancelcommand',\n        SELECTMULTIPLECHECKBOX: '.select-multiple-checkbox',\n        SELECTMULTIPLEDELETEBUTTON: '#selectmultipledeletecommand',\n        SELECTALL: '#questionselectall',\n        SHOW: 'a.' + CSS.SHOW,\n        SLOTLI: 'li.slot',\n        SUMMARKS: '.mod_quiz_summarks'\n    },\n    BODY = document.body;\n\nPrefetch.prefetchStrings('quiz',\n    ['numquestionsx', 'cannotremoveslots', 'cannotremoveallsectionslots', 'confirmremovequestion',\n        'confirmremovesectionheading', 'sectionnoname', 'sectionnoname', 'sectionheadingedit', 'sectionheadingedit',\n        'sectionheadingremove', 'sectionheadingremove', 'areyousureremoveselected']);\n\nPrefetch.prefetchStrings('moodle', ['edittitleinstructions', 'confirm',\n    'yes', 'confirm', 'edittitleinstructions']);\n\n/**\n * Resource and activity toolbox class.\n *\n * This class is responsible for managing AJAX interactions with activities and resources\n * when viewing a course in editing mode.\n */\nclass ToolBox {\n    config = {};\n    quizId = 0;\n    courseId = 0;\n\n    constructor(config, courseId, quizId) {\n        this.config = config;\n        this.courseId = courseId;\n        this.quizId = quizId;\n    }\n    /**\n     * Send a request using the REST API\n     *\n     * @param {Object} data The data to submit with the AJAX request\n     * @param {HTMLElement} [loadingElement] A element that need to be added spinner.\n     * @param {String} methodName The service name.\n     * @param {Object} [optionalConfig] Any additional configuration to submit\n     * @chainable\n     */\n    sendRequest(data, loadingElement, methodName, optionalConfig) {\n        const parameters = {\n            methodname: methodName,\n            args: data,\n        };\n\n        // Apply optional config\n        if (optionalConfig) {\n            for (let varName in optionalConfig) {\n                config[varName] = optionalConfig[varName];\n            }\n        }\n        let spinner = null;\n\n        if (loadingElement !== null) {\n            spinner = addIconToContainerWithPromise(loadingElement);\n        }\n\n        return fetchMany([parameters])[0].then(response => {\n            if (spinner !== null) {\n                spinner.resolve();\n            }\n\n            if (response.newnumquestions) {\n                getString('numquestionsx', 'quiz', response.newnumquestions).then(string => {\n                    document.querySelector(SELECTOR.NUMQUESTIONS).innerHTML = string;\n                    return true;\n                }).catch(() => {\n                    // Can't get lang string.\n                });\n            }\n            if (response.newsummarks) {\n                document.querySelector(SELECTOR.SUMMARKS).innerHTML = response.newsummarks;\n            }\n\n            return response;\n        });\n    }\n}\n\n/**\n * Resource and activity toolbox class.\n *\n * This is a class extending TOOLBOX containing code specific to resources\n *\n * This class is responsible for managing AJAX interactions with activities and resources\n * when viewing a quiz in editing mode.\n */\nclass ResourceToolBox extends ToolBox {\n    courseId = 0;\n    quizId = 0;\n    config = {};\n\n    /**\n     * An Array of events added when editing a max mark field.\n     * These should all be detached when editing is complete.\n     */\n    editMaxMarkEvents = false;\n\n    constructor(courseId, quizId, addEvent) {\n        const config = JSON.parse(document.querySelector(SELECTOR.CONFIGTOOLBOX).dataset.config);\n        super(config, courseId, quizId);\n        this.courseId = courseId;\n        this.quizId = quizId;\n        this.config = config;\n        if (addEvent) {\n            BODY.addEventListener('click', (event) => {\n                // Use event.target.closest to ensure event delegation works\n                if (event.target.closest(SELECTOR.ACTIVITYACTION) ||\n                    event.target.closest(SELECTOR.DEPENDENCY_LINK)) {\n                    this.handleDataAction(event);\n                }\n            });\n            this.handleQuestionNumberUpdate();\n            this.initialiseSelectMultiple();\n        }\n    }\n\n    /**\n     * Initialize the select multiple options\n     * Add actions to the buttons that enable multiple slots to be selected and managed at once.\n     *\n     * @protected\n     */\n    initialiseSelectMultiple() {\n        const body = document.body;\n\n        // Click select multiple button to show the select all options.\n        document.querySelector(SELECTOR.SELECTMULTIPLEBUTTON).addEventListener('click', function(e) {\n            e.preventDefault();\n            body.classList.add(CSS.SELECTMULTIPLE);\n        });\n\n        // Click cancel button to hide the select all options.\n        document.querySelector(SELECTOR.SELECTMULTIPLECANCELBUTTON).addEventListener('click', function(e) {\n            e.preventDefault();\n            body.classList.remove(CSS.SELECTMULTIPLE);\n        });\n\n        // Assign the delete method to the delete multiple button.\n        body.addEventListener('click', function(e) {\n            if (e.target.closest(SELECTOR.SELECTMULTIPLEDELETEBUTTON)) {\n                this.deleteMultipleAction(e);\n            }\n        }.bind(this));\n    }\n\n    /**\n     * Add data-attribute with slot number to inplace element when they are updated.\n     */\n    handleQuestionNumberUpdate() {\n        // Listen to the updated inplace editable event when user updates the question number.\n        BODY.addEventListener(inplaceEditableEvents.elementUpdated, function(e) {\n            if (e.target.parentNode.classList.contains('slotnumber')) {\n                e.target.parentNode.setAttribute('data-customnumber', e.detail.ajaxreturn.displayvalue);\n            }\n        });\n    }\n\n    /**\n     * Handles the delegation event. When this is fired someone has triggered an action.\n     *\n     * Note not all actions will result in an AJAX enhancement.\n     *\n     * @param {Event} ev The event that was triggered.\n     * @returns {boolean}\n     */\n    handleDataAction(ev) {\n        // We need to get the anchor element that triggered this event.\n        let node = ev.target;\n        if (!(this.isATag(node))) {\n            node = node.closest(SELECTOR.ACTIVITYACTION);\n        }\n\n        // From the anchor we can get both the activity (added during initialisation) and the action being\n        // performed (added by the UI as a data attribute).\n        const action = node.dataset.action,\n            activity = node.closest(SELECTOR.ACTIVITYLI);\n\n        if (!(this.isATag(node)) || !action || !activity) {\n            // It wasn't a valid action node.\n            return;\n        }\n\n        // Switch based upon the action and do the desired thing.\n        switch (action) {\n            case 'editmaxmark':\n                // The user wishes to edit the max mark of the resource.\n                this.editMaxMark(ev, node, activity);\n                break;\n            case 'delete':\n                // The user is deleting the activity.\n                this.deleteWithConfirmation(ev, node, activity, action);\n                break;\n            case 'addpagebreak':\n            case 'removepagebreak':\n                // The user is adding or removing a page break.\n                this.updatePageBreak(ev, node, activity, action);\n                break;\n            case 'adddependency':\n            case 'removedependency':\n                // The user is adding or removing a dependency between questions.\n                this.updateDependency(ev, node, activity, action);\n                break;\n            default:\n                // Nothing to do here!\n                break;\n        }\n    }\n\n    isATag(node) {\n        return node.tagName.toLowerCase() === 'a';\n    }\n\n    /**\n     * Edit the max mark for the resource.\n     *\n     * @param {Event} ev The event that was fired.\n     * @param {HTMLElement} button The button that triggered this action.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     * @return Boolean\n     */\n    editMaxMark(ev, button, activity) {\n        // Prevent the default actions.\n        ev.preventDefault();\n        // Get the element we're working on.\n        const instanceMaxmark = activity.querySelector(SELECTOR.INSTANCEMAXMARK);\n        if (!instanceMaxmark) {\n            return;\n        }\n        const instance = activity.querySelector(SELECTOR.ACTIVITYINSTANCE),\n            anchor = instanceMaxmark, // Grab the anchor so that we can swap it with the edit form.\n            oldMaxMark = instanceMaxmark.firstChild.nodeValue,\n            data = {\n                'id': slot.getId(activity),\n                'quizid': this.quizId,\n            };\n        let maxMarkText = oldMaxMark;\n\n        this.sendRequest(data, null, 'mod_quiz_get_max_mark')\n            .then(response => {\n                if (M.core.actionmenu && M.core.actionmenu.instance) {\n                    M.core.actionmenu.instance.hideMenu(ev);\n                }\n                // Try to retrieve the existing string from the server.\n                if (response.instancemaxmark) {\n                    maxMarkText = response.instancemaxmark;\n                }\n\n                // Create the editor and submit button.\n                const editForm = util.createElement(\"form\", {action: '#'});\n\n                const editInstructions = util.createElement('span', {\n                    id: 'id_editinstructions',\n                    \"class\": CSS.EDITINSTRUCTIONS,\n                });\n\n                getString('edittitleinstructions', 'moodle').then(string => {\n                    editInstructions.innerHTML = string;\n                    return true;\n                }).catch(() => {\n                    // Can't get lang string.\n                });\n\n                const editor = util.createElement('input', {\n                    type: 'text',\n                    name: 'maxmark',\n                    \"class\": CSS.TITLEEDITOR,\n                    value: maxMarkText,\n                    autocomplete: 'off',\n                    ['aria-describedby']: 'id_editinstructions',\n                    maxLength: 12,\n                    size: parseInt(this.config.questiondecimalpoints, 10) + 2,\n                });\n\n\n                // Clear the existing content and put the editor in.\n                editForm.appendChild(editor);\n                editForm.dataset.anchor = anchor.outerHTML;\n                instance.parentNode.insertBefore(editInstructions, instance);\n                // Replace anchor span with the editForm input to edit.\n                activity.querySelector(SELECTOR.MAXMARKCONTAINER).replaceChild(editForm, anchor);\n\n                // We hide various components whilst editing:\n                activity.classList.add(CSS.EDITINGMAXMARK);\n\n                // Focus and select the editor text.\n                editor.focus();\n                editor.select();\n\n                // Cancel the edit if we lose focus or the escape key is pressed.\n                editor.addEventListener('blur', event =>\n                    this.handleMaxMarkEditorBlur(event, activity, false));\n                editor.addEventListener('keydown', event =>\n                    this.handleMaxMarkEditorType(event, activity, true));\n                // Handle form submission.\n                editForm.addEventListener('submit', event =>\n                    this.handleMaxMarkFormSubmit(event, activity, oldMaxMark));\n\n                // Store the event listeners for later removal\n                this.editMaxMarkEvents = true;\n\n                return true;\n            }).catch(Notification.exception);\n    }\n\n    /**\n     * Takes care of what needs to happen when the user clicks on the delete multiple button.\n     *\n     * @param {Event} ev The event that was fired.\n     */\n    deleteMultipleAction(ev) {\n        const problemSection = this.findSectionsThatWouldBecomeEmpty();\n\n        if (typeof problemSection !== 'undefined') {\n            getStrings([\n                {key: 'cannotremoveslots', component: 'quiz'},\n                {key: 'cannotremoveallsectionslots', component: 'quiz', param: problemSection},\n            ]).then(([string1, string2]) => {\n                Notification.alert(\n                    string1,\n                    string2,\n                );\n                return true;\n            }).catch(Notification.exception);\n        } else {\n            this.deleteMultipleWithConfirmation(ev);\n        }\n    }\n\n    /**\n     * Finds the section that would become empty if we remove the selected slots.\n     *\n     * @returns {String} The name of the first section found\n     */\n    findSectionsThatWouldBecomeEmpty() {\n        let section;\n        const sectionNodes = [...document.querySelectorAll(SELECTOR.SECTIONLI)];\n\n        if (sectionNodes.length > 1) {\n            sectionNodes.some((node) => {\n                const sectionName = node.querySelector(SELECTOR.INSTANCESECTION).textContent;\n                const checked = node.querySelectorAll(`${SELECTOR.SELECTMULTIPLECHECKBOX}:checked`);\n                const unchecked = node.querySelectorAll(`${SELECTOR.SELECTMULTIPLECHECKBOX}:not(:checked)`);\n                if (checked.length > 0 && unchecked.length === 0) {\n                    section = sectionName;\n                }\n\n                return section;\n            });\n        }\n\n        return section;\n    }\n\n    /**\n     * Deletes the given activities or resources after confirmation.\n     *\n     * @param {Event} ev The event that was fired.\n     */\n    async deleteMultipleWithConfirmation(ev) {\n        ev.preventDefault();\n\n        let ids = '';\n        const slots = [];\n        document.querySelectorAll(`${SELECTOR.SELECTMULTIPLECHECKBOX}:checked`).forEach((node) => {\n            const slotData = slot.getSlotFromComponent(node);\n            ids += ids === '' ? '' : ',';\n            ids += slot.getId(slotData);\n            slots.push(slotData);\n        });\n        const element = document.querySelector('div.mod-quiz-edit-content');\n\n        // Do nothing if no slots are selected.\n        if (!slots.length) {\n            return;\n        }\n\n        const [title, question, saveLabel] = await getStrings([\n            {key: 'confirm', component: 'moodle'},\n            {key: 'areyousureremoveselected', component: 'quiz'},\n            {key: 'yes', component: 'moodle'},\n        ]);\n\n        Notification.saveCancelPromise(\n            title,\n            question,\n            saveLabel,\n        ).then(() => {\n            const data = {\n                ids: ids,\n                quizid: this.quizId,\n            };\n            // Delete items on server.\n            this.sendRequest(data, element, 'mod_quiz_delete_multiple').then(response => {\n                // Delete locally if deleted on server.\n                if (response.deleted) {\n                    // Actually remove the element.\n                    document.querySelectorAll(`${SELECTOR.SELECTMULTIPLECHECKBOX}:checked`).forEach((node) => {\n                        slot.remove(node.closest('li.activity'));\n                    });\n                    // Update the page numbers and sections.\n                    this.reorganiseEditPage();\n\n                    // Remove the select multiple options.\n                    document.body.classList.remove(CSS.SELECTMULTIPLE);\n                }\n                return true;\n            }).catch(Notification.exception);\n            return true;\n        }).catch(() => {\n            // User cancelled.\n        });\n    }\n\n    /**\n     * Event to handle max mark when blur.\n     *\n     * @param {Event} event the blur event of current node.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     * @param {Boolean} preventDefault\n     */\n    handleMaxMarkEditorBlur(event, activity, preventDefault) {\n        return this.editMaxMarkCancel(event, activity, preventDefault);\n    }\n\n    /**\n     * Event to handle max mark when escape.\n     *\n     * @param {Event} event the key down event of current node.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     * @param {Boolean} preventDefault\n     */\n    handleMaxMarkEditorType(event, activity, preventDefault) {\n        if (event.key === 'Escape' || event.keyCode === 27) {\n            this.editMaxMarkCancel(event, activity, preventDefault);\n        }\n    }\n\n    /**\n     * Event to handle max mark when submit.\n     *\n     * @param {Event} event the submit event of current node.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     * @param {String} oldMaxMark the old value of max mark.\n     */\n    handleMaxMarkFormSubmit(event, activity, oldMaxMark) {\n        event.preventDefault(); // Prevent the default form submission behavior\n        return this.editMaxMarkSubmit(event, activity, oldMaxMark);\n    }\n\n    /**\n     * Deletes the given activity or resource after confirmation.\n     *\n     * @param {Event} ev The event that was fired.\n     * @param {HTMLElement} button The button that triggered this action.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     */\n    async deleteWithConfirmation(ev, button, activity) {\n        // Prevent the default button action.\n        ev.preventDefault();\n\n        // Get the element we're working on.\n        const element = activity;\n        const qtypeClass = element.getAttribute('class').match(/qtype_(\\S*)/)[1];\n\n        // Create confirm string (different if element has or does not have name)\n        const qtypeName = await getString('pluginname', 'qtype_' + qtypeClass);\n        const allStrings = [\n            {key: 'confirm', component: 'moodle'},\n            {key: 'confirmremovequestion', component: 'quiz', param: qtypeName},\n            {key: 'yes', component: 'moodle'},\n        ];\n        const [title, question, saveLabel] = await getStrings(allStrings);\n\n        try {\n            await Notification.saveCancelPromise(\n                title,\n                question,\n                saveLabel,\n            );\n            const data = {\n                'quizid': this.quizId,\n                'id': slot.getId(element) // Adjusting the YUI namespace\n            };\n            this.sendRequest(data, element, 'mod_quiz_delete_resource').then(response => {\n                if (response.deleted) {\n                    // Actually remove the element.\n                    slot.remove(element);\n                    this.reorganiseEditPage();\n                    if (M.core.actionmenu && M.core.actionmenu.instance) {\n                        M.core.actionmenu.instance.hideMenu(ev);\n                    }\n                }\n                return true;\n            }).catch(Notification.exception);\n        } catch (e) {\n            // User cancelled.\n        }\n    }\n\n    /**\n     * Reorganise the UI after every edit action.\n     */\n    reorganiseEditPage() {\n        slot.reorderSlots();\n        slot.reorderPageBreaks();\n        page.reorderPages();\n        slot.updateOneSlotSections();\n        slot.updateAllDependencyIcons();\n    }\n\n    /**\n     * Joins or separates the given slot with the page of the previous slot. Reorders the pages of\n     * the other slots.\n     *\n     * @protected\n     * @param {Event} ev - The event that was fired.\n     * @param {HTMLElement} button - The button that triggered this action.\n     * @param {HTMLElement} activity - The activity node that this action will be performed on.\n     * @param {string} action - The action, addpagebreak or removepagebreak.\n     */\n    updatePageBreak(ev, button, activity, action) {\n        // Prevent the default button action\n        ev.preventDefault();\n\n        let nextActivity = activity.nextElementSibling;\n\n        while (nextActivity && !nextActivity.matches(SELECTOR.SLOTLI)) {\n            nextActivity = nextActivity.nextElementSibling;\n        }\n\n        if (!nextActivity) {\n            return;\n        }\n\n        const value = action === 'removepagebreak' ? 1 : 2;\n\n        const data = {\n            'id': slot.getId(nextActivity),\n            'value': value,\n            'quizid': this.quizId,\n        };\n\n        this.sendRequest(data, nextActivity, 'mod_quiz_update_page_break').then(response => {\n            if (response.slots) {\n                if (action === 'addpagebreak') {\n                    page.add(activity);\n                } else {\n                    const pageEl = activity.nextElementSibling\n                        && activity.nextElementSibling.matches(page.SELECTORS.PAGE) ? activity.nextElementSibling : null;\n                    if (pageEl) {\n                        page.remove(pageEl, true);\n                    }\n                }\n                this.reorganizeEditPage();\n            }\n            return true;\n        }).catch(Notification.exception);\n    }\n\n    /**\n     * Updates a slot to either require the question in the previous slot to\n     * have been answered, or not.\n     *\n     * @param {Event} ev The event that was fired.\n     * @param {Node} button The button that triggered this action.\n     * @param {Node} activity The activity node that this action will be performed on.\n     * @param {String} action The action, adddependency or removedependency.\n     */\n    updateDependency(ev, button, activity, action) {\n        // Prevent the default button action.\n        ev.preventDefault();\n\n        const data = {\n            id: slot.getId(activity),\n            value: action === 'adddependency' ? 1 : 0,\n            quizid: this.quizId,\n        };\n\n        this.sendRequest(data, activity, 'mod_quiz_update_dependency').then(response => {\n            if (response.hasOwnProperty('requireprevious')) {\n                slot.updateDependencyIcon(activity, response.requireprevious);\n            }\n\n            return true;\n        }).catch(Notification.exception);\n    }\n\n\n    /**\n     * Reorganise the UI after every edit action.\n     */\n    reorganizeEditPage() {\n        slot.reorderSlots();\n        slot.reorderPageBreaks();\n        page.reorderPages();\n        slot.updateOneSlotSections();\n        slot.updateAllDependencyIcons();\n    }\n\n    /**\n     * Handles the cancel event when editing the activity or resources maxmark.\n     *\n     * @param {Event} ev The event that triggered this.\n     * @param {Node} activity The activity whose maxmark we are altering.\n     * @param {Boolean} preventDefault If true we should prevent the default action from occuring.\n     */\n    editMaxMarkCancel(ev, activity, preventDefault) {\n        if (preventDefault) {\n            ev.preventDefault();\n        }\n\n        this.editMaxMarkClear(activity);\n    }\n\n    /**\n     * Handles clearing the editing UI and returning things to the original state they were in.\n     *\n     * @param {HTMLElement} activity  The activity whose maxmark we were altering.\n     */\n    editMaxMarkClear(activity) {\n        // Detach all listen events to prevent duplicate triggers\n        if (!this.editMaxMarkEvents) {\n            return;\n        }\n\n        this.editMaxMarkEvents = false;\n\n        const editForm = activity.querySelector(SELECTOR.ACTIVITYFORM),\n            instructions = activity.querySelector('#id_editinstructions');\n        if (editForm) {\n            editForm.parentNode.insertAdjacentHTML('afterbegin', editForm.dataset.anchor);\n            editForm.remove();\n        }\n        if (instructions) {\n            instructions.parentNode.removeChild(instructions);\n        }\n\n        // Remove the editing class again to revert the display.\n        activity.classList.remove(CSS.EDITINGMAXMARK);\n\n        // Refocus the link which was clicked originally so the user can continue using keyboard nav.\n        setTimeout(function() {\n            activity.querySelector(SELECTOR.EDITMAXMARK).focus();\n        }, 100);\n\n        // TODO MDL-50768 This hack is to keep Behat happy until they release a version of\n        // MinkSelenium2Driver that fixes\n        // https://github.com/Behat/MinkSelenium2Driver/issues/80.\n        if (!document.querySelector('input[name=maxmark]')) {\n            const input = util.createElement('input', {\n                type: 'text',\n                name: 'maxmark',\n                \"class\": 'd-none',\n            });\n            document.querySelector('body').appendChild(input);\n        }\n    }\n\n    /**\n     * Handles the submit event when editing the activity or resources maxmark.\n     *\n     * @param {Event} ev The event that triggered this.\n     * @param {HTMLElement} activity The activity whose max mark we are altering.\n     * @param {String} originalMaxMark The original max mark the activity or resource had.\n     */\n    editMaxMarkSubmit(ev, activity, originalMaxMark) {\n        // We don't actually want to submit anything.\n        ev.preventDefault();\n        const editor = activity.querySelector(SELECTOR.ACTIVITYFORM + ' ' + SELECTOR.ACTIVITYMAXMARK);\n        // The value should cointain only number.\n        editor.value = parseFloat(editor.value.trim());\n        const newMaxMark = /^\\d+$/.test(editor.value) ? editor.value : 0;\n        // Try to blur input to trigger event editMaxMarkClear.\n        editor.blur();\n        // Update the instance max mark content\n        activity.querySelector(SELECTOR.INSTANCEMAXMARK).textContent = newMaxMark;\n\n        if (newMaxMark !== null && newMaxMark !== \"\" && newMaxMark !== originalMaxMark) {\n            const data = {\n                'maxmark': newMaxMark,\n                'id': slot.getId(activity), // Adjusting the namespace.\n                'quizid': this.quizId,\n            };\n            this.sendRequest(data, activity, 'mod_quiz_update_max_mark').then(response => {\n                if (response.instancemaxmark) {\n                    activity.querySelector(SELECTOR.INSTANCEMAXMARK).textContent = response.instancemaxmark;\n                }\n                return true;\n            }).catch(Notification.exception);\n        }\n    }\n\n    /**\n     * Add a loading icon to the specified activity.\n     * The icon is added within the action area.\n     *\n     * @param {HTMLElement} activity The activity to add a loading icon to\n     * @return {HTMLElement|null} The newly created icon, or null if the action area was not found.\n     */\n    addSpinner(activity) {\n        const actionArea = activity.querySelector(SELECTOR.ACTIONAREA);\n        if (actionArea) {\n            return util.addSpinner(actionArea);\n        }\n\n        return null;\n    }\n}\n\n/**\n * Section toolbox class.\n *\n * This class is responsible for managing AJAX interactions with sections\n * when adding, editing, removing section headings.\n */\nclass SectionToolBox extends ToolBox {\n    /**\n     * An Array of events added when editing a max mark field.\n     * These should all be detached when editing is complete.\n     */\n    editSectionEvents = false;\n\n    /**\n     * Initialize the section toolboxes module.\n     * Updates all span. Commands with relevant handlers and other required changes.\n     *\n     * @param {Number} courseId The ID of the Moodle Course being edited.\n     * @param {Number} quizId The ID of the quiz being edited.\n     */\n    constructor(courseId, quizId) {\n        const config = JSON.parse(document.querySelector(SELECTOR.CONFIGTOOLBOX).dataset.config);\n        super(config, courseId, quizId);\n        this.courseId = courseId;\n        this.quizId = quizId;\n        this.config = config;\n\n        BODY.addEventListener('keydown', (event) => {\n            if (event.key === 'Enter' && event.target.closest(SELECTOR.ACTIVITYACTION)) {\n                this.handleDataAction(event);\n            }\n        });\n\n        BODY.addEventListener('click', (event) => {\n            if (event.target.closest(SELECTOR.ACTIVITYACTION)) {\n                this.handleDataAction(event);\n            }\n        });\n\n        BODY.addEventListener('change', (event) => {\n            if (event.target.closest(SELECTOR.EDITSHUFFLEQUESTIONSACTION)) {\n                this.handleDataAction(event);\n            }\n        });\n    }\n\n    /**\n     * Handles the delegation event. When this is fired someone has triggered an action.\n     *\n     * Note not all actions will result in an AJAX enhancement.\n     *\n     * @param {Event} ev The event that was triggered.\n     * @returns {boolean}\n     */\n    handleDataAction(ev) {\n        // We need to get the anchor element that triggered this event.\n        let node = ev.target;\n        if (!node.matches('a') && !node.matches('input[data-action]')) {\n            node = node.closest(SELECTOR.ACTIVITYACTION);\n        }\n\n        // From the anchor we can get both the activity (added during initialization) and the action being\n        // performed (added by the UI as a data attribute).\n        const action = node ? node.getAttribute('data-action') : null;\n        const activity = node ? node.closest(SELECTOR.ACTIVITYLI) : null;\n\n        if ((!node.matches('a') && !node.matches('input[data-action]')) || !action || !activity) {\n            // It wasn't a valid action node.\n            return false;\n        }\n\n        // Switch based upon the action and do the desired thing.\n        switch (action) {\n            case 'edit_section_title':\n                // The user wishes to edit the section headings.\n                this.editSectionTitle(ev, node, activity);\n                break;\n            case 'shuffle_questions':\n                // The user wishes to edit the shuffle questions of the section (resource).\n                this.editShuffleQuestions(ev, node, activity);\n                break;\n            case 'deletesection':\n                // The user is deleting the activity.\n                this.deleteSectionWithConfirmation(ev, node, activity);\n                break;\n            default:\n                // Nothing to do here!\n                break;\n        }\n\n        return true;\n    }\n\n    /**\n     * Deletes the given section heading after confirmation.\n     *\n     * @param {Event} ev The event that was fired.\n     * @param {HTMLElement} button The button that triggered this action.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     * @chainable\n     */\n    async deleteSectionWithConfirmation(ev, button, activity) {\n        ev.preventDefault();\n        const [title, question, saveLabel] = await getStrings([\n            {key: 'confirm', component: 'moodle'},\n            {key: 'confirmremovesectionheading', component: 'quiz', param: activity.dataset.sectionname},\n            {key: 'yes', component: 'moodle'},\n        ]);\n        Notification.saveCancelPromise(\n            title,\n            question,\n            saveLabel\n        ).then(() => {\n            const data = {\n                'id': activity.id.replace('section-', ''),\n                'quizid': this.quizId,\n            };\n            this.sendRequest(data, activity.querySelector(SELECTOR.ACTIONAREA), 'mod_quiz_delete_section').then((response) => {\n                if (response.deleted) {\n                    window.location.reload(true);\n                }\n                return true;\n            }).catch(Notification.exception);\n            return true;\n        }).catch(() => {\n            // User cancelled.\n        });\n    }\n\n    /**\n     * Edit the edit section title for the section.\n     *\n     * @param {Event} ev The event that was fired.\n     * @param {HTMLElement} button The button that triggered this action.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     * @return {Boolean}\n     */\n    editSectionTitle(ev, button, activity) {\n        // Get the element we're working on\n        const activityId = activity.id.replace('section-', '');\n        const instanceSection = activity.querySelector(SELECTOR.INSTANCESECTION);\n        let anchor = instanceSection; // Grab the anchor so that we can swap it with the edit form.\n        const data = {\n            'id': activityId,\n            'quizid': this.quizId,\n        };\n\n        // Prevent the default actions.\n        ev.preventDefault();\n\n        this.sendRequest(data, null, 'mod_quiz_get_section_title').then(response => {\n            // Try to retrieve the existing string from the server.\n            const oldText = response.instancesection;\n\n            // Create the editor and submit button.\n            const editForm = util.createElement('form', {action: '#'});\n            const editInstructions = util.createElement('span', {\"class\": CSS.EDITINSTRUCTIONS,\n                id: 'id_editinstructions'});\n            getString('edittitleinstructions', 'moodle').then(string => {\n                editInstructions.innerHTML = string;\n                return true;\n            }).catch(() => {\n                // Can't get lang string.\n            });\n            const editor = util.createElement('input', {name: 'section', type: 'text', value: oldText,\n                autocomplete: 'off', 'aria-describedby': 'id_editinstructions', maxLength: 255});\n\n            // Clear the existing content and put the editor in.\n            editForm.appendChild(editor);\n            editForm.dataset.anchor = anchor.outerHTML;\n            instanceSection.parentNode.insertBefore(editInstructions, instanceSection);\n            activity.querySelector(SELECTOR.SECTIONINSTANCE).replaceChild(editForm, anchor);\n\n            // Focus and select the editor text.\n            editor.focus();\n            editor.select();\n            // Cancel the edit if we lose focus or the escape key is pressed.\n            editor.addEventListener('blur', event => this.editSectionTitleCancel(event, activity, false));\n            editor.addEventListener('keydown', (event) => {\n                if (event.key === 'Escape') {\n                    this.editSectionTitleCancel(event, activity, true);\n                }\n            });\n            // Handle form submission.\n            editForm.addEventListener('submit', (event) => this.editSectionTitleSubmit(event, activity, oldText));\n            this.editSectionEvents = true;\n            return true;\n        }).catch(Notification.exception);\n    }\n\n    /**\n     * Handles the submit event when editing section heading.\n     *\n     * @param {Event} ev The event that triggered this.\n     * @param {HTMLElement} activity The activity whose section heading we are editing.\n     * @param {String} oldText The original section heading.\n     */\n    async editSectionTitleSubmit(ev, activity, oldText) {\n        // We don't actually want to submit anything.\n        ev.preventDefault();\n        const newTextInput = activity.querySelector(`${SELECTOR.SECTIONFORM} ${SELECTOR.SECTIONINPUT}`);\n        let newText = newTextInput.value.trim();\n        this.editSectionTitleClear(activity);\n\n        if (newText === null || newText === oldText) {\n            return;\n        }\n\n        const instanceSection = activity.querySelector(SELECTOR.INSTANCESECTION);\n        let instanceSectionText = newText;\n        if (newText.trim() === '') {\n            // Add a sr-only default section heading text to ensure we don't end up with an empty section heading.\n            instanceSectionText = await getString('sectionnoname', 'quiz');\n            instanceSection.classList.add('sr-only');\n        } else {\n            // Show the section heading when a non-empty value is set.\n            instanceSection.classList.remove('sr-only');\n        }\n        instanceSection.textContent = instanceSectionText;\n\n        const data = {\n            'newheading': newText,\n            'id': activity.id.replace('section-', ''),\n            'quizid': this.quizId,\n        };\n\n        try {\n            const response = await this.sendRequest(data, activity.querySelector(SELECTOR.INSTANCESECTIONAREA),\n                'mod_quiz_update_section_title');\n            if (response) {\n                // Set the content of the section heading if for some reason the response is different from the new text.\n                // e.g. filters were applied, the update failed, etc.\n                if (newText !== response.instancesection) {\n                    if (response.instancesection.trim() === '') {\n                        // Add a sr-only default section heading text.\n                        instanceSectionText = await getString('sectionnoname', 'quiz');\n                        instanceSection.classList.add('sr-only');\n                    } else {\n                        instanceSectionText = response.instancesection;\n                        // Show the section heading when a non-empty value is set.\n                        instanceSection.classList.remove('sr-only');\n                    }\n                    instanceSection.textContent = instanceSectionText;\n                }\n\n                const editSectionIcon = activity.querySelector(SELECTOR.EDITSECTIONICON);\n                editSectionIcon.title = await getString('sectionheadingedit', 'quiz', response.instancesection);\n                editSectionIcon.alt = await getString('sectionheadingedit', 'quiz', response.instancesection);\n\n                const deleteIcon = activity.querySelector(SELECTOR.DELETESECTIONICON);\n                if (deleteIcon) {\n                    deleteIcon.title = await getString('sectionheadingremove', 'quiz', response.instancesection);\n                    deleteIcon.alt = await getString('sectionheadingremove', 'quiz', response.instancesection);\n                }\n            }\n        } catch (error) {\n            // Ignore.\n        }\n    }\n\n    /**\n     * Handles the cancel event when editing the section heading.\n     *\n     * @param {Event} ev The event that triggered this.\n     * @param {HTMLElement} activity The activity whose section heading we are editing.\n     * @param {Boolean} preventDefault If true we should prevent the default action from occuring.\n     */\n    editSectionTitleCancel(ev, activity, preventDefault) {\n        if (preventDefault) {\n            ev.preventDefault();\n        }\n        this.editSectionTitleClear(activity);\n    }\n\n    /**\n     * Handles clearing the editing UI and returning things to the original state.\n     *\n     * @param {HTMLElement} activity The activity whose section heading we were editing.\n     */\n    editSectionTitleClear(activity) {\n        // Detach all listen events to prevent duplicate triggers\n        if (!this.editSectionEvents) {\n            return;\n        }\n        this.editSectionEvents = false;\n\n        const editForm = activity.querySelector(SELECTOR.SECTIONFORM);\n        const instructions = activity.querySelector('#id_editinstructions');\n\n        if (editForm) {\n            editForm.parentNode.insertAdjacentHTML('afterbegin', editForm.dataset.anchor);\n            editForm.remove();\n        }\n        if (instructions) {\n            instructions.remove();\n        }\n\n        // Refocus the link which was clicked originally so the user can continue using keyboard nav.\n        setTimeout(() => activity.querySelector(SELECTOR.EDITSECTION).focus(), 100);\n\n        // This hack is to keep Behat happy until they release a version of MinkSelenium2Driver that fixes\n        // https://github.com/Behat/MinkSelenium2Driver/issues/80.\n        if (!document.querySelector('input[name=section]')) {\n            const input = util.createElement('input', {\n                type: 'text',\n                name: 'section',\n                \"class\": 'd-none',\n            });\n            document.querySelector('body').appendChild(input);\n        }\n    }\n\n    /**\n     * Edit the shuffle questions for the section.\n     *\n     * @param {Event} ev The event that was fired.\n     * @param {HTMLElement} button The button that triggered this action.\n     * @param {HTMLElement} activity The activity node that this action will be performed on.\n     * @return {Boolean}\n     */\n    editShuffleQuestions(ev, button, activity) {\n        let newValue;\n        if (activity.querySelector(SELECTOR.EDITSHUFFLEQUESTIONSACTION).checked) {\n            newValue = 1;\n            activity.classList.add('shuffled');\n        } else {\n            newValue = 0;\n            activity.classList.remove('shuffled');\n        }\n\n        // Prevent default behavior\n        ev.preventDefault();\n\n        // Prepare data object\n        const data = {\n            id: activity.id.replace('section-', ''),\n            newshuffle: newValue,\n            quizid: this.quizId,\n        };\n\n        // Send request (replace with your fetch implementation)\n        this.sendRequest(data, activity.querySelector(SELECTOR.EDITSHUFFLEAREA), 'mod_quiz_update_shuffle_questions');\n    }\n}\n\n/**\n * Init resource toolbox method.\n *\n * @param {Number} courseId The ID of the Moodle Course being edited.\n * @param {Number} quizId The ID of the quiz being edited.\n * @param {Boolean} addEvent The flag to add event. True is add event.\n */\nfunction initResourceToolbox(courseId, quizId, addEvent = true) {\n    return new ResourceToolBox(courseId, quizId, addEvent);\n}\n\n/**\n * Init section toolbox method.\n *\n * @param {Number} courseId The ID of the Moodle Course being edited.\n * @param {Number} quizId The ID of the quiz being edited.\n */\nfunction initSectionToolbox(courseId, quizId) {\n    new SectionToolBox(courseId, quizId);\n}\nconst config = JSON.parse(document.querySelector(SELECTOR.CONFIGTOOLBOX).dataset.config);\n\nexport {\n    initResourceToolbox,\n    initSectionToolbox,\n    config,\n};"],"names":["courseId","quizId","addEvent","ResourceToolBox","SectionToolBox","CSS","SELECTOR","ACTIONAREA","ACTIONLINKTEXT","ACTIVITYACTION","ACTIVITYFORM","ACTIVITYINSTANCE","SECTIONINSTANCE","ACTIVITYLI","ACTIVITYMAXMARK","COMMANDSPAN","CONFIGTOOLBOX","CONTENTAFTERLINK","CONTENTWITHOUTLINK","DELETESECTIONICON","EDITMAXMARK","EDITSECTION","EDITSECTIONICON","EDITSHUFFLEQUESTIONSACTION","EDITSHUFFLEAREA","HIDE","HIGHLIGHT","INSTANCENAME","INSTANCEMAXMARK","INSTANCESECTION","INSTANCESECTIONAREA","MAXMARKCONTAINER","MODINDENTDIV","MODINDENTOUTER","NUMQUESTIONS","PAGECONTENT","PAGELI","SECTIONLI","SECTIONUL","SECTIONFORM","SECTIONINPUT","SELECTMULTIPLEBUTTON","SELECTMULTIPLECANCELBUTTON","SELECTMULTIPLECHECKBOX","SELECTMULTIPLEDELETEBUTTON","SELECTALL","SHOW","SLOTLI","SUMMARKS","BODY","document","body","prefetchStrings","ToolBox","constructor","config","sendRequest","data","loadingElement","methodName","optionalConfig","parameters","methodname","args","varName","spinner","then","response","resolve","newnumquestions","string","querySelector","innerHTML","catch","newsummarks","JSON","parse","dataset","addEventListener","event","target","closest","DEPENDENCY_LINK","handleDataAction","handleQuestionNumberUpdate","initialiseSelectMultiple","e","preventDefault","classList","add","remove","deleteMultipleAction","bind","this","inplaceEditableEvents","elementUpdated","parentNode","contains","setAttribute","detail","ajaxreturn","displayvalue","ev","node","isATag","action","activity","editMaxMark","deleteWithConfirmation","updatePageBreak","updateDependency","tagName","toLowerCase","button","instanceMaxmark","instance","anchor","oldMaxMark","firstChild","nodeValue","slot","getId","maxMarkText","M","core","actionmenu","hideMenu","instancemaxmark","editForm","util","createElement","editInstructions","id","editor","type","name","value","autocomplete","maxLength","size","parseInt","questiondecimalpoints","appendChild","outerHTML","insertBefore","replaceChild","focus","select","handleMaxMarkEditorBlur","handleMaxMarkEditorType","handleMaxMarkFormSubmit","editMaxMarkEvents","Notification","exception","problemSection","findSectionsThatWouldBecomeEmpty","key","component","param","_ref","string1","string2","alert","deleteMultipleWithConfirmation","section","sectionNodes","querySelectorAll","length","some","sectionName","textContent","checked","unchecked","ids","slots","forEach","slotData","getSlotFromComponent","push","element","title","question","saveLabel","saveCancelPromise","quizid","deleted","reorganiseEditPage","editMaxMarkCancel","keyCode","editMaxMarkSubmit","qtypeClass","getAttribute","match","allStrings","reorderSlots","reorderPageBreaks","reorderPages","updateOneSlotSections","updateAllDependencyIcons","nextActivity","nextElementSibling","matches","pageEl","page","SELECTORS","PAGE","reorganizeEditPage","hasOwnProperty","updateDependencyIcon","requireprevious","editMaxMarkClear","instructions","insertAdjacentHTML","removeChild","setTimeout","input","originalMaxMark","parseFloat","trim","newMaxMark","test","blur","addSpinner","actionArea","editSectionTitle","editShuffleQuestions","deleteSectionWithConfirmation","sectionname","replace","window","location","reload","activityId","instanceSection","oldText","instancesection","editSectionTitleCancel","editSectionTitleSubmit","editSectionEvents","newText","editSectionTitleClear","instanceSectionText","editSectionIcon","alt","deleteIcon","error","newValue","newshuffle"],"mappings":"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"}